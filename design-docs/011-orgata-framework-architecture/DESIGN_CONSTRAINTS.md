Here's a list of design requirements and definitions that the framework will need to support:
* The most basic unit of execution is an Operation. It is composed of two parts, a Context and an Implmentation. The Context takes an Input, passes it to the Implementation which does something to it (defined in plain english as a Method), and then may or may not send an Output. It is essentially a function or method in code, abstracted. 
* A Capability is just an interface for an Operation, it puts a name to an operation, with a desciption and clarifies the required input and ouput.
* A Method is just one or more text steps that is translated into an Implementation inside an Operation at compile time.
* An Input or Output is a serializable data object with a defined schema. It needs to have some set of typed key-value pairs.
* A Context is like a microruntime for the operation. It has any instances to fulfill needed Capabilities for the Operation as well as infrastructure-level or low-level businesss Capabilities (like logging or authorization checks). Like a programming language will make sure a function has memory and compute time, the Context will abstract away any need to instanteate and manage any infrastructure being used in the Operation. It can be extended with middleware that is not necessarily defined in the BUSY file.
* A Context also provides basic messaging and routing for any coordination needed for the Operation, acting as sort of message bus. It handles the actual messaging of the Input and Output and any other messaging (eventing, signaling) needed to be sent to sibling or parent Operations via their Contexts.
* An Implementation is the actual code that is generated or plugged into. It will be one Class with one Method/Function that is called by the Context. The Context will also provide or inject all needed resources, tools, references, etc. that Implemenation needs. It will also handle any exceptions that are raised up.
* A OperationSet is any collection of one or more Capabilities. It may also be a Capability. Though each Operation will still have it's own Context, an OperationSet will also provide a shared Context for it's collection of Operations. 

That should be all the atomic composable parts needed. Next are the "moleucles" or various combinations of these:
* A Process is just a OperationSet for N+1 steps. The +1 Operation is the actual flow control, the definition of the process itself. So if a process has 3 consecutive steps, the 4th flow Operation will intiate, send a message via the Context to the 1st step Operation, recieve a response, then move on down the line until complete. 
* An OrgataOperation is also an OperationSet that translates a Capability into a DefaultControlStrategy Operation that coordinates set of 3 sub-Operations that all have the same business logic: algorithm (code), agent (AI), and/or human (UI). The algorithm will have actual compilable code will execute at runtime. Agent will have a prompt. Human will provide a view model (in MVP parlance) and blocking to provide that model to the user in some way and wait for input from the user. It may be more akin to a DTO (data transfer object) than a view model, depending on how the transport layer is implemented (not a concern yet in this framework). The ControlStrategy Oepration adopt or defer a strategy of how they interact with each other. For instance, it may start with Algorithm, fail and be caught by AI to attempt to fix, and then finally be passed to a human to handle. These "gears" should be able to be defined, inhereted, assumed, defaulted at design time but also shifted, reconfigured, or overridden at runtime.

