import { AnalysisResult } from '../analysis/types';
import { promises as fs } from 'fs';
import path from 'path';

export interface FrameworkGenerationOptions {
  outputPath: string;
  packageName: string;
  overwrite: boolean;
  includeTests: boolean;
}

export interface FrameworkGenerationResult {
  processClasses: number;
  stepClasses: number;
  humanSteps: number;
  algorithmSteps: number;
  agentSteps: number;
}

export class FrameworkGenerator {
  constructor(private options: FrameworkGenerationOptions) {}

  async generateFramework(analysisResult: AnalysisResult): Promise<FrameworkGenerationResult> {
    console.log('üöÄ Starting Orgata Framework Code Generation...');
    console.log(`üìÅ Output Path: ${this.options.outputPath}`);
    console.log(`üì¶ Package Name: ${this.options.packageName}`);
    
    // Ensure output directory exists
    if (this.options.overwrite) {
      await fs.rm(this.options.outputPath, { recursive: true, force: true });
    }
    await fs.mkdir(this.options.outputPath, { recursive: true });
    
    // Create directory structure
    await this.createDirectoryStructure();
    
    // Generate package.json
    await this.generatePackageJson();
    
    // Generate TypeScript configuration
    await this.generateTsConfig();
    
    // Process each playbook
    const result: FrameworkGenerationResult = {
      processClasses: 0,
      stepClasses: 0,
      humanSteps: 0,
      algorithmSteps: 0,
      agentSteps: 0
    };
    
    for (const [playbookId, playbook] of analysisResult.ast.symbols.playbooks) {
      console.log(`\nüìñ Processing playbook: ${playbook.name}`);
      
      const playbookResult = await this.generatePlaybookCode(playbook);
      
      result.processClasses += playbookResult.processClasses;
      result.stepClasses += playbookResult.stepClasses;
      result.humanSteps += playbookResult.humanSteps;
      result.algorithmSteps += playbookResult.algorithmSteps;
      result.agentSteps += playbookResult.agentSteps;
    }
    
    // Generate index files
    await this.generateIndexFiles(analysisResult);
    
    // Generate README
    await this.generateReadme(analysisResult, result);
    
    console.log('\n‚úÖ Framework generation completed!');
    return result;
  }
  
  private async createDirectoryStructure(): Promise<void> {
    const dirs = [
      'src',
      'src/processes',
      'src/steps',
      'src/types',
      'src/__tests__'
    ];
    
    for (const dir of dirs) {
      await fs.mkdir(path.join(this.options.outputPath, dir), { recursive: true });
    }
  }
  
  private async generatePackageJson(): Promise<void> {
    const packageJson = {
      name: this.options.packageName,
      version: '1.0.0',
      description: 'Generated business process framework code from BUSY files',
      main: 'dist/index.js',
      types: 'dist/index.d.ts',
      scripts: {
        build: 'tsc',
        dev: 'tsc --watch',
        test: 'jest',
        lint: 'eslint src --ext .ts'
      },
      dependencies: {
        '@orgata/framework': '0.1.0'
      },
      devDependencies: {
        typescript: '^5.0.0',
        '@types/node': '^20.0.0',
        jest: '^29.0.0',
        '@types/jest': '^29.0.0',
        'ts-jest': '^29.0.0',
        eslint: '^8.0.0',
        '@typescript-eslint/eslint-plugin': '^6.0.0',
        '@typescript-eslint/parser': '^6.0.0'
      },
      keywords: [
        'business-process',
        'orgata-framework',
        'typescript',
        'workflow'
      ],
      author: 'Generated by BUSY Compiler',
      license: 'MIT'
    };
    
    await fs.writeFile(
      path.join(this.options.outputPath, 'package.json'),
      JSON.stringify(packageJson, null, 2)
    );
  }
  
  private async generateTsConfig(): Promise<void> {
    const tsConfig = {
      compilerOptions: {
        target: 'ES2020',
        module: 'commonjs',
        lib: ['ES2020'],
        outDir: './dist',
        rootDir: './src',
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        declaration: true,
        declarationMap: true,
        sourceMap: true
      },
      include: ['src/**/*'],
      exclude: ['node_modules', 'dist']
    };
    
    await fs.writeFile(
      path.join(this.options.outputPath, 'tsconfig.json'),
      JSON.stringify(tsConfig, null, 2)
    );
  }
  
  private async generatePlaybookCode(playbook: any): Promise<FrameworkGenerationResult> {
    const result: FrameworkGenerationResult = {
      processClasses: 0,
      stepClasses: 0,
      humanSteps: 0,
      algorithmSteps: 0,
      agentSteps: 0
    };
    
    // Generate process class
    const processCode = this.generateProcessClass(playbook);
    const processFileName = this.toKebabCase(playbook.name) + '-process.ts';
    await fs.writeFile(
      path.join(this.options.outputPath, 'src/processes', processFileName),
      processCode
    );
    result.processClasses++;
    
    // Generate step classes
    if (playbook.node.steps) {
      for (const step of playbook.node.steps) {
        const stepType = this.determineStepType(step);
        const stepCode = this.generateStepClass(step, stepType);
        const stepFileName = this.toKebabCase(step.name) + '-step.ts';
        
        await fs.writeFile(
          path.join(this.options.outputPath, 'src/steps', stepFileName),
          stepCode
        );
        
        result.stepClasses++;
        if (stepType === 'human') result.humanSteps++;
        else if (stepType === 'algorithm') result.algorithmSteps++;
        else if (stepType === 'agent') result.agentSteps++;
      }
    }
    
    return result;
  }
  
  private generateProcessClass(playbook: any): string {
    const className = this.toPascalCase(playbook.name);
    const stepImports = playbook.node.steps?.map((step: any) => 
      `import { ${this.toPascalCase(step.name)}Step } from '../steps/${this.toKebabCase(step.name)}-step';`
    ).join('\n') || '';
    
    return `/**
 * ${playbook.name} Process
 * 
 * Generated from: ${playbook.name}.busy
 * Description: ${playbook.node.description || 'Business process implementation'}
 * 
 * üîó Design Source: ../../design-docs/008-orgata-framework/ORGATA_FRAMEWORK_ARCHITECTURE.md
 */

import { Process, ProcessConfig, ProcessContext, ProcessResult } from '@orgata/framework';
${stepImports}

export class ${className}Process extends Process {
  constructor() {
    super({
      name: "${playbook.name}",
      description: "${playbook.node.description || 'Business process implementation'}",
      layer: "L0",
      metadata: {
        generatedFrom: "${playbook.name}.busy",
        generatedAt: "${new Date().toISOString()}",
        busyVersion: "1.0.0"
      }
    });
    
    // Add all steps in sequence
${playbook.node.steps?.map((step: any) => 
  `    this.addStep(new ${this.toPascalCase(step.name)}Step());`
).join('\n') || '    // No steps defined'}
  }
  
  async execute(context: ProcessContext): Promise<ProcessResult> {
    // Framework handles step-by-step execution with complete flexibility
    // Users can skip steps, go back, or provide manual data at any point
    return await this.executeSteps(context);
  }
}`;
  }
  
  private generateStepClass(step: any, stepType: 'human' | 'agent' | 'algorithm'): string {
    const className = this.toPascalCase(step.name);
    
    switch (stepType) {
      case 'human':
        return this.generateHumanStep(step, className);
      case 'agent':
        return this.generateAgentStep(step, className);
      case 'algorithm':
        return this.generateAlgorithmStep(step, className);
      default:
        throw new Error(`Unknown step type: ${stepType}`);
    }
  }
  
  private generateHumanStep(step: any, className: string): string {
    const fields = this.generateFieldsForStep(step);
    
    return `/**
 * ${step.name} - ${step.description}
 * 
 * Human interaction step with flexible UI and complete override capabilities.
 * 
 * üîó Design Source: ../../design-docs/008-orgata-framework/FRAMEWORK_API_SPECIFICATION.md
 */

import { HumanStep, HumanStepConfig, StepContext, StepResult, FieldType, StepType } from '@orgata/framework';

export class ${className}Step extends HumanStep {
  constructor() {
    super({
      id: '${step.name}',
      name: '${step.name.replace(/_/g, ' ').replace(/\b\w/g, (l: string) => l.toUpperCase())}',
      description: '${step.description}',
      type: StepType.HUMAN,
      model: {
        fields: [
${fields.map(field => this.renderField(field)).join(',\n')}
        ],
        layout: {
          type: 'single-column',
          columns: 1
        },
        validation: {
          strategy: 'on-blur',
          showErrorsOn: 'after-interaction'
        },
        metadata: {
          version: '1.0.0',
          generatedFrom: '${step.name}.busy'
        }
      },
      view: {
        type: 'form',
        props: {
          allowFreeForm: true,  // Framework philosophy: never constrain
          showSkipOption: true,
          enableManualDataEntry: true
        },
        styling: {
          className: 'orgata-human-step-form'
        },
        behavior: {
          validation: {
            realTime: false,
            debounceMs: 500,
            showErrors: true
          }
        }
      }
    });
  }
  
  // Override to add custom business logic if needed
  protected async processUserInput(input: any, context: StepContext): Promise<any> {
    // TODO: Implement business logic based on: ${step.description}
    return input;
  }
}`;
  }
  
  private generateAgentStep(step: any, className: string): string {
    return `/**
 * ${step.name} - ${step.description}
 * 
 * AI Agent step with intelligent processing and human review capability.
 * 
 * üîó Design Source: ../../design-docs/008-orgata-framework/FRAMEWORK_API_SPECIFICATION.md
 */

import { AgentStep, AgentStepConfig, StepContext, StepResult, AgentResponse, AlgorithmInput, AlgorithmOutput, StepType } from '@orgata/framework';

export class ${className}Step extends AgentStep {
  constructor() {
    super({
      id: '${step.name}',
      name: '${step.name.replace(/_/g, ' ').replace(/\b\w/g, (l: string) => l.toUpperCase())}',
      description: '${step.description}',
      type: StepType.AGENT,
      prompt: {
        systemPrompt: \`You are an expert assistant helping with ${step.description.toLowerCase()}. 
        Provide thorough analysis and actionable recommendations.\`,
        userPrompt: \`Please ${step.description.toLowerCase()} based on the provided context: {{context}}\`,
        context: {
          businessDomain: 'business-process',
          expectedFormat: 'structured_data',
          qualityCriteria: ['accuracy', 'completeness', 'actionability']
        },
        constraints: {
          maxTokens: 1000,
          temperature: 0.3,
          requireStructuredOutput: true
        }
      },
      context: {} as any, // TODO: Implement proper AgentContext
      constraints: {
        timeout: 30000,
        retryAttempts: 3,
        fallbackToHuman: true  // Framework philosophy: always provide escape hatch
      }
    });
  }
  
  protected extractRelevantContext(context: StepContext): Record<string, any> {
    // TODO: Extract relevant data for ${step.description}
    return {
      context: JSON.stringify(context.inputData),
      businessContext: context.businessContext
    };
  }
}`;
  }
  
  private generateAlgorithmStep(step: any, className: string): string {
    return `/**
 * ${step.name} - ${step.description}
 * 
 * Algorithm step with automated processing and manual override capability.
 * 
 * üîó Design Source: ../../design-docs/008-orgata-framework/FRAMEWORK_API_SPECIFICATION.md
 */

import { AlgorithmStep, AlgorithmStepConfig, StepContext, StepResult, AlgorithmInput, AlgorithmOutput, StepType } from '@orgata/framework';

export class ${className}Step extends AlgorithmStep {
  constructor() {
    super({
      id: '${step.name}',
      name: '${step.name.replace(/_/g, ' ').replace(/\b\w/g, (l: string) => l.toUpperCase())}',
      description: '${step.description}',
      type: StepType.ALGORITHM,
      implementation: {
        type: '${step.algorithm || 'custom'}',
        version: '1.0.0',
        config: {
          timeout: 30000,
          retryAttempts: 3
        }
      },
      parameters: {}
    });
  }
  
  protected async executeAlgorithm(input: AlgorithmInput): Promise<AlgorithmOutput> {
    // TODO: Implement algorithm for: ${step.description}
    // 
    // Algorithm type: ${step.algorithm || 'custom'}
    // Estimated duration: ${step.estimated_duration || 'unknown'}
    //
    // Framework ensures users can always override this with manual data
    
    throw new Error('Algorithm implementation required for ${step.name}');
  }
  
  protected extractInputs(context: StepContext): AlgorithmInput {
    // TODO: Extract required inputs from previous steps
    return {
      stepContext: context.inputData,
      parameters: this.parameters
    };
  }
}`;
  }
  
  private generateFieldsForStep(step: any): any[] {
    // Simple field generation based on step content
    // In a real implementation, this would use AI/ML to analyze step descriptions
    const fields: any[] = [];
    
    const description = step.description?.toLowerCase() || '';
    
    // Pattern-based field generation
    if (description.includes('name') || description.includes('contact')) {
      fields.push({ name: 'contactName', type: 'TEXT', label: 'Contact Name', required: true });
    }
    
    if (description.includes('email')) {
      fields.push({ name: 'email', type: 'EMAIL', label: 'Email Address', required: true });
    }
    
    if (description.includes('phone')) {
      fields.push({ name: 'phone', type: 'PHONE', label: 'Phone Number', required: false });
    }
    
    if (description.includes('date') || description.includes('schedule')) {
      fields.push({ name: 'date', type: 'DATE', label: 'Date', required: true });
    }
    
    if (description.includes('notes') || description.includes('comment')) {
      fields.push({ name: 'notes', type: 'TEXTAREA', label: 'Notes', required: false });
    }
    
    // Default field if none detected
    if (fields.length === 0) {
      fields.push({ name: 'data', type: 'TEXTAREA', label: 'Step Data', required: false });
    }
    
    return fields;
  }
  
  private renderField(field: any): string {
    return `          {
            id: '${field.name}',
            name: '${field.name}',
            type: FieldType.${field.type},
            label: '${field.label}',
            required: ${field.required},
            validation: []
          }`;
  }
  
  private determineStepType(step: any): 'human' | 'agent' | 'algorithm' {
    // Use execution_type from BUSY file if available
    if (step.execution_type === 'human') return 'human';
    if (step.execution_type === 'algorithmic') return 'algorithm';
    
    // Infer from description patterns
    const description = step.description?.toLowerCase() || '';
    
    // AI/analysis tasks
    if (description.includes('assess') || description.includes('analyze') || 
        description.includes('evaluate') || description.includes('review')) {
      return step.execution_type === 'human' ? 'human' : 'agent';
    }
    
    // Automated tasks
    if (description.includes('generate') || description.includes('process') || 
        description.includes('send') || description.includes('calculate')) {
      return 'algorithm';
    }
    
    // Default to human for interactive tasks
    return step.execution_type === 'human' ? 'human' : 'algorithm';
  }
  
  private async generateIndexFiles(analysisResult: AnalysisResult): Promise<void> {
    const playbooks = Array.from(analysisResult.ast.symbols.playbooks.values());
    
    // Main index.ts
    const mainIndex = `/**
 * Generated Business Process Framework Code
 * 
 * üîó Design Source: ../../design-docs/008-orgata-framework/ORGATA_FRAMEWORK_ARCHITECTURE.md
 */

// Process exports
${playbooks.map(playbook => 
  `export { ${this.toPascalCase(playbook.name)}Process } from './processes/${this.toKebabCase(playbook.name)}-process';`
).join('\n')}

// Step exports
${playbooks.flatMap(playbook => 
  playbook.node.steps?.map((step: any) => 
    `export { ${this.toPascalCase(step.name)}Step } from './steps/${this.toKebabCase(step.name)}-step';`
  ) || []
).join('\n')}

// Metadata
export const GENERATED_METADATA = {
  generatedAt: '${new Date().toISOString()}',
  frameworkVersion: '0.1.0',
  processCount: ${playbooks.length},
  busySources: [${playbooks.map(p => `'${p.name}.busy'`).join(', ')}]
};`;
    
    await fs.writeFile(path.join(this.options.outputPath, 'src/index.ts'), mainIndex);
  }
  
  private async generateReadme(analysisResult: AnalysisResult, result: FrameworkGenerationResult): Promise<void> {
    const playbooks = Array.from(analysisResult.ast.symbols.playbooks.values());
    
    const readme = `# ${this.options.packageName}

Generated business process framework code from BUSY files using the Orgata Framework.

## Overview

This package contains TypeScript framework code that implements business processes with complete flexibility and user control.

## Generated Components

- **${result.processClasses} Process Classes**: Complete business process implementations
- **${result.stepClasses} Step Classes**: Individual step implementations
  - ${result.humanSteps} Human Steps (with generated UI forms)
  - ${result.algorithmSteps} Algorithm Steps (automated processing)
  - ${result.agentSteps} Agent Steps (AI-powered analysis)

## Processes

${playbooks.map(playbook => `### ${playbook.name}
- **Description**: ${playbook.node.description || 'Business process implementation'}
- **Steps**: ${playbook.node.steps?.length || 0}
- **Layer**: L0`).join('\n\n')}

## Usage

\`\`\`typescript
import { ${playbooks.map(p => this.toPascalCase(p.name) + 'Process').join(', ')} } from '${this.options.packageName}';
import { ProcessContext } from '@orgata/framework';

// Create process instance
const process = new ${this.toPascalCase(playbooks[0]?.name || 'Example')}Process();

// Execute with context
const context: ProcessContext = {
  processId: 'process-001',
  userId: 'user-123',
  sessionId: 'session-456',
  environment: 'production',
  businessContext: {
    industry: 'your-industry',
    businessSize: 'small',
    organizationId: 'org-123'
  },
  permissions: {
    canSkipSteps: true,
    canOverrideValidation: true,
    canModifyProcess: false,
    canViewAuditTrail: true
  }
};

const result = await process.execute(context);
\`\`\`

## Framework Philosophy: "Facilitate, Never Constrain"

This generated code follows the Orgata Framework principles:

- **Complete Flexibility**: Users can skip any step and provide manual data
- **Immutable State**: All changes tracked with event sourcing
- **Audit Trail**: Complete history of all actions and decisions
- **AI Integration**: Intelligent assistance with human oversight
- **Never Rewrite History**: Forward-only progression with exception tracking

## Installation

\`\`\`bash
npm install @orgata/framework
npm install
\`\`\`

## Development

\`\`\`bash
npm run build    # Compile TypeScript
npm run test     # Run tests
npm run lint     # Check code quality
\`\`\`

## Generated Files

- \`src/processes/\` - Process class implementations
- \`src/steps/\` - Individual step implementations
- \`src/index.ts\` - Main exports

Generated on: ${new Date().toISOString()}
`;
    
    await fs.writeFile(path.join(this.options.outputPath, 'README.md'), readme);
  }
  
  private toPascalCase(str: string): string {
    return str.replace(/(^|[_-])([a-z])/g, (match, sep, letter) => letter.toUpperCase());
  }
  
  private toKebabCase(str: string): string {
    return str.replace(/_/g, '-').toLowerCase();
  }
}

export async function generateFramework(
  analysisResult: AnalysisResult,
  options: FrameworkGenerationOptions
): Promise<FrameworkGenerationResult> {
  const generator = new FrameworkGenerator(options);
  return await generator.generateFramework(analysisResult);
}