# BUSY Compiler Project Structure

This document describes the organized structure of the BUSY language compiler project after cleanup and reorganization.

## Directory Structure

```
busy-lang/compiler/
├── README.md                    # Main project README
├── PROJECT_STRUCTURE.md         # This file - project organization guide
├── package.json                 # Node.js dependencies and scripts
├── tsconfig.json               # TypeScript configuration
├── jest.config.js              # Test configuration
├── busy-validate.js            # Quick validation script
├── analysis.json               # Analysis results cache
│
├── src/                        # Source code
│   ├── index.ts               # Main entry point
│   ├── core/                  # Core compilation pipeline
│   │   ├── scanner.ts         # File discovery and scanning
│   │   └── parser.ts          # YAML parsing and validation
│   ├── ast/                   # Abstract Syntax Tree
│   │   ├── nodes.ts           # AST node definitions
│   │   └── builder.ts         # AST construction
│   ├── symbols/               # Symbol table management
│   │   └── table.ts           # Symbol registration and tracking
│   ├── analysis/              # Multi-pass analysis engine
│   │   ├── analyzer.ts        # Main analysis orchestrator
│   │   ├── semantic-analyzer.ts # Semantic validation
│   │   ├── dependency-resolver.ts # Dependency graph analysis
│   │   ├── type-checker.ts    # Type system validation
│   │   ├── interface-validator.ts # Interface compatibility
│   │   ├── governance-validator.ts # Policy compliance
│   │   ├── resource-analyzer.ts # Resource allocation
│   │   ├── performance-analyzer.ts # Performance analysis
│   │   ├── security-analyzer.ts # Security validation
│   │   ├── quality-analyzer.ts # Code quality metrics
│   │   ├── types.ts           # Analysis type definitions
│   │   └── index.ts           # Analysis exports
│   ├── cli/                   # Command-line interface
│   │   ├── index.ts           # CLI entry point
│   │   ├── types.ts           # CLI type definitions
│   │   ├── commands/          # CLI commands
│   │   │   ├── validate.ts    # Validation command
│   │   │   ├── analyze.ts     # Analysis command
│   │   │   └── watch.ts       # Watch mode command
│   │   └── reporters/         # Output formatters
│   │       ├── console.ts     # Console output
│   │       ├── json.ts        # JSON output
│   │       └── html.ts        # HTML report output
│   ├── config/                # Configuration management
│   │   ├── types.ts           # Configuration types
│   │   └── loader.ts          # Configuration loading
│   ├── utils/                 # Utility functions
│   │   ├── yaml-utils.ts      # YAML processing utilities
│   │   ├── path-utils.ts      # Path manipulation utilities
│   │   └── debounce.ts        # Debouncing utilities
│   ├── types.ts               # Global type definitions
│   └── quick-validate.ts      # Lightweight validation
│
├── schemas/                    # JSON schemas
│   ├── busy-schema.json       # BUSY language schema
│   └── config-schema.json     # Configuration schema
│
├── tests/                      # Test suite
│   └── (test files)           # Unit and integration tests
│
├── dist/                      # Compiled JavaScript output
│   └── (compiled files)       # Generated by TypeScript
│
├── docs/                      # Complete documentation suite
│   ├── README.md              # Documentation overview
│   ├── DOCUMENTATION_INDEX.md # Central documentation hub
│   ├── BUSY_LANGUAGE_REFERENCE.md # Complete syntax reference
│   ├── DEVELOPER_LLM_GUIDE.md # Developer and LLM workflows
│   ├── VALIDATION_ERRORS_REFERENCE.md # Error catalog
│   ├── COMPILER_ARCHITECTURE.md # Architecture documentation
│   ├── DESIGN.md              # Original design document
│   ├── implementation-plan.md # Historical implementation planning
│   └── error-system.md        # Error handling system design
│
└── design-docs/               # Iterative improvement designs
    ├── README.md              # Design process documentation
    ├── BUSY_SPECIFICATION_CHANGES_DESIGN.md # Current spec changes
    └── IMPLEMENTATION_TASK_BREAKDOWN.md # Implementation planning
```

## Organization Principles

### 1. Separation of Concerns
- **`src/`**: All implementation code organized by function
- **`docs/`**: User-facing documentation for current system
- **`design-docs/`**: Future evolution and design planning
- **`schemas/`**: Formal specifications and validation rules

### 2. Documentation Strategy
- **Current State**: `docs/` contains comprehensive documentation of existing system
- **Future Planning**: `design-docs/` contains proposals and planning for evolution
- **Historical Record**: Design documents become permanent record of decisions

### 3. User-Centric Organization
- **BUSY Developers**: Start with `docs/BUSY_LANGUAGE_REFERENCE.md`
- **LLM Assistants**: Focus on `docs/DEVELOPER_LLM_GUIDE.md`
- **Compiler Maintainers**: Begin with `docs/COMPILER_ARCHITECTURE.md`
- **Project Evolution**: Review `design-docs/` for planned changes

## File Naming Conventions

### Source Code
- **kebab-case** for file names (`semantic-analyzer.ts`)
- **PascalCase** for class names (`SemanticAnalyzer`)
- **camelCase** for function and variable names

### Documentation
- **UPPER_CASE** for major documents (`BUSY_LANGUAGE_REFERENCE.md`)
- **kebab-case** for supporting documents (`error-system.md`)
- **Descriptive names** that clearly indicate content and purpose

### Design Documents
- **Feature-based naming** with consistent format
- **Design documents**: `{FEATURE_NAME}_DESIGN.md`
- **Implementation plans**: `{FEATURE_NAME}_IMPLEMENTATION.md` or `IMPLEMENTATION_{FEATURE_NAME}.md`

## Navigation Guide

### Quick Start Paths

#### New BUSY Developer
```
1. README.md (project overview)
2. docs/BUSY_LANGUAGE_REFERENCE.md (syntax)
3. docs/DEVELOPER_LLM_GUIDE.md (workflow)
4. docs/VALIDATION_ERRORS_REFERENCE.md (troubleshooting)
```

#### LLM Assistant
```
1. docs/DEVELOPER_LLM_GUIDE.md (assistance guidelines)
2. docs/BUSY_LANGUAGE_REFERENCE.md (syntax reference)
3. docs/VALIDATION_ERRORS_REFERENCE.md (error handling)
```

#### Compiler Contributor
```
1. docs/COMPILER_ARCHITECTURE.md (architecture)
2. docs/DESIGN.md (historical context)
3. src/ (implementation)
4. design-docs/ (future plans)
```

#### Project Stakeholder
```
1. README.md (project overview)
2. docs/DOCUMENTATION_INDEX.md (documentation map)
3. design-docs/ (planned improvements)
```

## Maintenance Guidelines

### Documentation Updates
- **Feature Changes**: Update relevant docs in `docs/` when implementing
- **New Features**: Add to language reference and developer guide
- **Error Changes**: Update validation error reference
- **Architecture Changes**: Update compiler architecture documentation

### Design Evolution
- **New Proposals**: Create new design documents in `design-docs/`
- **Implementation Planning**: Create detailed task breakdowns
- **Historical Record**: Preserve design documents as project history
- **Review Process**: Use design documents for stakeholder review

### Quality Standards
- **Consistency**: Maintain consistent terminology across all documentation
- **Accuracy**: All examples must validate against current compiler
- **Completeness**: Cover all features, patterns, and error conditions
- **Clarity**: Target appropriate audience and use clear language

## Benefits of This Structure

### 1. Clear Separation
- **Current vs Future**: Clear distinction between current documentation and future planning
- **User vs Maintainer**: Different entry points for different audiences
- **Reference vs Guide**: Both comprehensive reference and practical guides

### 2. Scalable Evolution
- **Design Process**: Structured approach to planning changes
- **Historical Record**: Preserve decision-making rationale
- **Iterative Improvement**: Support for continuous enhancement

### 3. User Experience
- **Multiple Entry Points**: Different paths for different users
- **Progressive Disclosure**: Start simple, add detail as needed
- **Comprehensive Coverage**: Everything documented and discoverable

This organization supports both current usage and future evolution while maintaining clarity and usability for all stakeholders.