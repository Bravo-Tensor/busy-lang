{
  "build_basic_workspace_playbook#_copyworkspacetemplate": {
    "operation": {
      "ref": "build_basic_workspace_playbook#_copyworkspacetemplate",
      "title": "_CopyWorkspaceTemplate",
      "content": "- **Purpose:** Materialize the template workspace that ships with inbox/outbox directories and starter instructions.\n- **Steps:**\n    1. Log entry: `timestamp | Build Basic Workspace Playbook -> _CopyWorkspaceTemplate | Starting template copy and link update.`\n    2. Export `WORKSPACE_ROOT` to the desired absolute path (e.g., `export WORKSPACE_ROOT=\"$(pwd)/agents/basic-workspace\"`).\n    2. Create the destination parent directory if necessary: `mkdir -p \"$(dirname \"$WORKSPACE_ROOT\")\"`.\n    3. Copy the template: `cp -R base/templates/basic-workspace \"$WORKSPACE_ROOT\"` (this writes the inbox/outbox folders, `.gitkeep` markers, `.trace/`, `instructions.md`, and `instructions.test.md`).\n    4. Update links in copied BUSY docs to point to project-level .busy files:\n        - `sed -i '' 's|:/.busy/|:../../../.busy/|g' \"$WORKSPACE_ROOT/instructions.md\"`\n        - `sed -i '' 's|:/.busy/|:../../../.busy/|g' \"$WORKSPACE_ROOT/instructions.test.md\"`\n    5. Confirm that `$WORKSPACE_ROOT/.trace/` exists and retains its `.gitkeep` placeholder so the directory is tracked across commits.\n    6. Log exit: `timestamp | Build Basic Workspace Playbook -> _CopyWorkspaceTemplate | Completed template copy and link update.`",
      "attrs": {},
      "steps": [
        "**Purpose:** Materialize the template workspace that ships with inbox/outbox directories and starter instructions.",
        "**Steps:**",
        "Log entry: `timestamp | Build Basic Workspace Playbook -> _CopyWorkspaceTemplate | Starting template copy and link update.`",
        "Export `WORKSPACE_ROOT` to the desired absolute path (e.g., `export WORKSPACE_ROOT=\"$(pwd)/agents/basic-workspace\"`).",
        "Create the destination parent directory if necessary: `mkdir -p \"$(dirname \"$WORKSPACE_ROOT\")\"`.",
        "Copy the template: `cp -R base/templates/basic-workspace \"$WORKSPACE_ROOT\"` (this writes the inbox/outbox folders, `.gitkeep` markers, `.trace/`, `instructions.md`, and `instructions.test.md`).",
        "Update links in copied BUSY docs to point to project-level .busy files:",
        "`sed -i '' 's|:/.busy/|:../../../.busy/|g' \"$WORKSPACE_ROOT/instructions.md\"`",
        "`sed -i '' 's|:/.busy/|:../../../.busy/|g' \"$WORKSPACE_ROOT/instructions.test.md\"`",
        "Confirm that `$WORKSPACE_ROOT/.trace/` exists and retains its `.gitkeep` placeholder so the directory is tracked across commits.",
        "Log exit: `timestamp | Build Basic Workspace Playbook -> _CopyWorkspaceTemplate | Completed template copy and link update.`"
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Tool": {
        "docId": "tool"
      },
      "BusyAssistant": {
        "docId": "busy_assistant"
      },
      "EvaluateDocument": {
        "docId": "document",
        "slug": "evaluatedocument"
      },
      "ExecutePlaybook": {
        "docId": "playbook",
        "slug": "executeplaybook"
      },
      "ListPlaybookSteps": {
        "docId": "playbook",
        "slug": "listplaybooksteps"
      }
    }
  },
  "build_basic_workspace_playbook#_reviewtemplateinstructions": {
    "operation": {
      "ref": "build_basic_workspace_playbook#_reviewtemplateinstructions",
      "title": "_ReviewTemplateInstructions",
      "content": "- **Purpose:** Tailor the BUSY-formatted instructions that ship with the template to your specific domain.\n- **Steps:**\n    1. Log entry: `timestamp | Build Basic Workspace Playbook -> _ReviewTemplateInstructions | Starting review of template instructions.`\n    2. Open `$WORKSPACE_ROOT/instructions.md` (copied from the template) and read the frontmatter plus the guidance sections that reference the BUSY library.\n    2. Incorporate any domain or project-specific expectations—add new BUSY document links, required tools, or output sections as needed.\n    3. Note any external assets the agent should rely on so downstream maintainers understand the workspace contract.\n    4. Log exit: `timestamp | Build Basic Workspace Playbook -> _ReviewTemplateInstructions | Completed review of template instructions.`",
      "attrs": {},
      "steps": [
        "**Purpose:** Tailor the BUSY-formatted instructions that ship with the template to your specific domain.",
        "**Steps:**",
        "Log entry: `timestamp | Build Basic Workspace Playbook -> _ReviewTemplateInstructions | Starting review of template instructions.`",
        "Open `$WORKSPACE_ROOT/instructions.md` (copied from the template) and read the frontmatter plus the guidance sections that reference the BUSY library.",
        "Incorporate any domain or project-specific expectations—add new BUSY document links, required tools, or output sections as needed.",
        "Note any external assets the agent should rely on so downstream maintainers understand the workspace contract.",
        "Log exit: `timestamp | Build Basic Workspace Playbook -> _ReviewTemplateInstructions | Completed review of template instructions.`"
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Tool": {
        "docId": "tool"
      },
      "BusyAssistant": {
        "docId": "busy_assistant"
      },
      "EvaluateDocument": {
        "docId": "document",
        "slug": "evaluatedocument"
      },
      "ExecutePlaybook": {
        "docId": "playbook",
        "slug": "executeplaybook"
      },
      "ListPlaybookSteps": {
        "docId": "playbook",
        "slug": "listplaybooksteps"
      }
    }
  },
  "build_basic_workspace_playbook#_validateworkspace": {
    "operation": {
      "ref": "build_basic_workspace_playbook#_validateworkspace",
      "title": "_ValidateWorkspace",
      "content": "- **Purpose:** Smoke-test the workspace by running the included test.\n- **Steps:**\n    1. Log entry: `timestamp | Build Basic Workspace Playbook -> _ValidateWorkspace | Starting workspace validation.`\n    2. Run the test suite defined in `$WORKSPACE_ROOT/instructions.test.md`.\n    2. Report the results to the user.\n    3. Log exit: `timestamp | Build Basic Workspace Playbook -> _ValidateWorkspace | Completed workspace validation.`",
      "attrs": {},
      "steps": [
        "**Purpose:** Smoke-test the workspace by running the included test.",
        "**Steps:**",
        "Log entry: `timestamp | Build Basic Workspace Playbook -> _ValidateWorkspace | Starting workspace validation.`",
        "Run the test suite defined in `$WORKSPACE_ROOT/instructions.test.md`.",
        "Report the results to the user.",
        "Log exit: `timestamp | Build Basic Workspace Playbook -> _ValidateWorkspace | Completed workspace validation.`"
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Tool": {
        "docId": "tool"
      },
      "BusyAssistant": {
        "docId": "busy_assistant"
      },
      "EvaluateDocument": {
        "docId": "document",
        "slug": "evaluatedocument"
      },
      "ExecutePlaybook": {
        "docId": "playbook",
        "slug": "executeplaybook"
      },
      "ListPlaybookSteps": {
        "docId": "playbook",
        "slug": "listplaybooksteps"
      }
    }
  },
  "build_basic_workspace_playbook#executeplaybook": {
    "operation": {
      "ref": "build_basic_workspace_playbook#executeplaybook",
      "title": "ExecutePlaybook",
      "content": "",
      "attrs": {},
      "steps": [],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Tool": {
        "docId": "tool"
      },
      "BusyAssistant": {
        "docId": "busy_assistant"
      },
      "EvaluateDocument": {
        "docId": "document",
        "slug": "evaluatedocument"
      },
      "ExecutePlaybook": {
        "docId": "playbook",
        "slug": "executeplaybook"
      },
      "ListPlaybookSteps": {
        "docId": "playbook",
        "slug": "listplaybooksteps"
      }
    }
  },
  "build_basic_workspace_playbook#listplaybooksteps": {
    "operation": {
      "ref": "build_basic_workspace_playbook#listplaybooksteps",
      "title": "ListPlaybookSteps",
      "content": "Execute [ListPlaybookSteps] after [EvaluateDocument] to enumerate Steps 1–3.",
      "attrs": {},
      "steps": [],
      "checklist": [
        "Confirm `$WORKSPACE_ROOT` contains the copied template workspace with inbox/outbox directories, `.busy/` assets, `.trace/`, and updated links.",
        "Confirm `$WORKSPACE_ROOT/instructions.md` reflects any project-specific guidance or note that none was required.",
        "Confirm `$WORKSPACE_ROOT/instructions.test.md` was executed and report the observed results to the user.",
        "Confirm `.trace/trace.log` is ready for use (create the file if this is the initial run)."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Tool": {
        "docId": "tool"
      },
      "BusyAssistant": {
        "docId": "busy_assistant"
      },
      "EvaluateDocument": {
        "docId": "document",
        "slug": "evaluatedocument"
      },
      "ExecutePlaybook": {
        "docId": "playbook",
        "slug": "executeplaybook"
      },
      "ListPlaybookSteps": {
        "docId": "playbook",
        "slug": "listplaybooksteps"
      }
    }
  },
  "busy_assistant#explainconcept": {
    "operation": {
      "ref": "busy_assistant#explainconcept",
      "title": "ExplainConcept",
      "content": "- **Input:** The name of a BUSY framework [Concept] (e.g., `Document`, `Operation`, `Tool`, `Playbook`).\n- **Steps:**\n    1.  Locate the core definition document for the requested [Concept].\n    2.  Read the document to understand its `Name`, `Description`, `[Setup](../core/document.busy.md#setup-section)`, and `[Operations](../core/document.busy.md#operations-section)`.\n    3.  Provide a clear, concise summary of the [Concept] to the user.\n    4.  Offer to provide more detail or an example if the user wishes.",
      "attrs": {},
      "steps": [
        "**Input:** The name of a BUSY framework [Concept] (e.g., `Document`, `Operation`, `Tool`, `Playbook`).",
        "**Steps:**",
        "Locate the core definition document for the requested [Concept].",
        "Read the document to understand its `Name`, `Description`, `[Setup](../core/document.busy.md#setup-section)`, and `[Operations](../core/document.busy.md#operations-section)`.",
        "Provide a clear, concise summary of the [Concept] to the user.",
        "Offer to provide more detail or an example if the user wishes."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "Tool": {
        "docId": "tool"
      },
      "Playbook": {
        "docId": "playbook"
      }
    }
  },
  "busy_assistant#createdocument": {
    "operation": {
      "ref": "busy_assistant#createdocument",
      "title": "CreateDocument",
      "content": "- **Input:** The type of [Document] to create (e.g., `Prompt`, `Role`) and a high-level goal for the document.\n- **Steps:**\n    1.  Ask clarifying questions to understand the user's requirements for the new [Document].\n    2.  Draft the content for the new [Document], including all necessary sections (Frontmatter, Imports, [Setup](../core/document.busy.md#setup-section), [Operations](../core/document.busy.md#operations-section)).\n    3.  Present the drafted [Document] to the user for approval.\n    4.  Write the new [Document] to a file path specified by the user.",
      "attrs": {},
      "steps": [
        "**Input:** The type of [Document] to create (e.g., `Prompt`, `Role`) and a high-level goal for the document.",
        "**Steps:**",
        "Ask clarifying questions to understand the user's requirements for the new [Document].",
        "Draft the content for the new [Document], including all necessary sections (Frontmatter, Imports, [Setup](../core/document.busy.md#setup-section), [Operations](../core/document.busy.md#operations-section)).",
        "Present the drafted [Document] to the user for approval.",
        "Write the new [Document] to a file path specified by the user."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "Tool": {
        "docId": "tool"
      },
      "Playbook": {
        "docId": "playbook"
      }
    }
  },
  "busy_assistant#listavailableoperations": {
    "operation": {
      "ref": "busy_assistant#listavailableoperations",
      "title": "ListAvailableOperations",
      "content": "- **Input:** An optional reference to a [Document].\n- **Steps:**\n    1.  If no [Document] is provided, use the [Operation]s for this [Role].\n    2.  If a [Document] is provided, parse it to identify all defined [Operation]s.\n    3.  [Display the list](../core/document.busy.md#listoperations) of [Operation]s to the user with a brief description of each.",
      "attrs": {},
      "steps": [
        "**Input:** An optional reference to a [Document].",
        "**Steps:**",
        "If no [Document] is provided, use the [Operation]s for this [Role].",
        "If a [Document] is provided, parse it to identify all defined [Operation]s.",
        "[Display the list](../core/document.busy.md#listoperations) of [Operation]s to the user with a brief description of each."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "Tool": {
        "docId": "tool"
      },
      "Playbook": {
        "docId": "playbook"
      }
    }
  },
  "busy_formatting_rules#runbusyformattingrules": {
    "operation": {
      "ref": "busy_formatting_rules#runbusyformattingrules",
      "title": "RunBusyFormattingRules",
      "content": "- **Purpose:** Validate that the target BUSY [Document] is formatted correctly before execution.\n- **[Input](../core/operation.busy.md#input):**\n    - `target_doc` — Path or identifier of the [Document] under review.\n\n1. Load `target_doc` and review it in the order [EvaluateDocument] enforces (frontmatter → imports → [Setup](../core/document.busy.md#setup-section) → [Operations](../core/document.busy.md#operations-section)).\n2. Compare the [Document] against each `Checklist` item below, gathering evidence for compliance.\n3. Flag any violations or ambiguities for follow-up.\n4. Invoke [RunChecklist] to confirm every item was verified.",
      "attrs": {},
      "steps": [
        "**Purpose:** Validate that the target BUSY [Document] is formatted correctly before execution.",
        "**[Input](../core/operation.busy.md#input):**",
        "`target_doc` — Path or identifier of the [Document] under review.",
        "Load `target_doc` and review it in the order [EvaluateDocument] enforces (frontmatter → imports → [Setup](../core/document.busy.md#setup-section) → [Operations](../core/document.busy.md#operations-section)).",
        "Compare the [Document] against each `Checklist` item below, gathering evidence for compliance.",
        "Flag any violations or ambiguities for follow-up.",
        "Invoke [RunChecklist] to confirm every item was verified."
      ],
      "checklist": [
        "Frontmatter and Imports",
        "Confirm frontmatter appears at the very top, delimited by `---`, and defines `Name`, `Type`, and `Description`.",
        "Confirm the frontmatter `Type` is a bracketed reference to the correct BUSY concept (e.g., `[Playbook]`, `[Tool]`).",
        "Confirm reference-style imports follow immediately after the frontmatter, one per line as `[Alias]:relative/path[#anchor]`.",
        "Verify each import path exists and any anchor resolves to a heading within the target file.",
        "Confirm a `# [Imports](../core/document.busy.md#imports-section)` heading appears directly above the reference definitions (even when no external imports are required).",
        "Concept References",
        "Confirm every section heading outside `# Local Definitions` wraps its title in a link to the concept it invokes (e.g., `# [Setup](path)`); if a heading is unlinked, ensure it introduces a new concept first defined under `# Local Definitions`.",
        "Confirm any local concepts are grouped under `# Local Definitions` using level-2 headings (`## ConceptName`) with canonical names so they can be referenced internally or externally.",
        "Verify new concepts are introduced only under `# Local Definitions`, and any later references link back to that definition or an import.",
        "Confirm concept references in prose are linked to their defining [Document]s (e.g., `[Operation]`, `[Checklist]`), or establish them under `# Local Definitions` before reuse.",
        "Confirm section links do not point back to the same heading (no self-referential anchors); they must reference a canonical concept definition or imported/local definition anchor.",
        "Sections and Operations",
        "Confirm a `# [Setup](../core/document.busy.md#setup-section)` section is present and either establishes required context or explicitly states when no setup actions are needed.",
        "When the [Document] defines callable work, confirm a `# [Operations](../core/document.busy.md#operations-section)` section exists.",
        "Confirm every [Operation] uses a level-2 heading (`##`) that links to its defining concept, states its intent, and lists numbered, imperative steps.",
        "Verify [Operation]s reference other BUSY assets through the defined imports instead of inline paths or unresolved links.",
        "Confirm [Operation]s that require verification conclude with a `### [Checklist](../core/checklist.busy.md#checklist)` of actionable, observable items.",
        "Execution Order and Persistence",
        "Confirm instructions that persist files or state identify destinations (e.g., memory files, workspace paths) per BUSY conventions.",
        "Verify the [Document] respects the [EvaluateDocument] order overall: frontmatter → imports → [Setup](../core/document.busy.md#setup-section) → [Operations](../core/document.busy.md#operations-section) (plus optional locals/teardown as needed), with no stray directives outside that flow."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Document": {
        "docId": "document"
      },
      "Concept": {
        "docId": "concept"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "EvaluateDocument": {
        "docId": "document",
        "slug": "evaluatedocument"
      },
      "RunChecklist": {
        "docId": "checklist",
        "slug": "runchecklist"
      }
    }
  },
  "workspace_agent#executeworkspace": {
    "operation": {
      "ref": "workspace_agent#executeworkspace",
      "title": "ExecuteWorkspace",
      "content": "- **Purpose:** Execute a complete workspace, handling role assumption, instruction execution, and output management.\n- **Input:** Path to workspace directory.\n- **Steps:**\n    1. **Check Validation Cache:**\n       - Read `.workspace` configuration\n       - If `validationCache.validated` is `true` and `validationCache.validationStatus` is `\"valid\"`:\n         - Skip to step 4 using cached `validationCache.workspaceType`\n         - Log cache hit to `trace.log`\n       - Otherwise, proceed to step 2\n    2. **Validate and Parse** (first-time only):\n       - Validate the workspace structure using [ValidateWorkspace](../core/workspace.busy.md#validateworkspace)\n       - Parse the `.workspace` configuration using [ParseWorkspaceConfig](../core/workspace.busy.md#parseworkspaceconfig)\n       - Determine workspace type using [DetectWorkspaceType](../core/workspace.busy.md#detectworkspacetype)\n       - Update `.workspace` file with validation cache:\n         ```json\n         \"validationCache\": {\n           \"validated\": true,\n           \"timestamp\": \"<current ISO timestamp>\",\n           \"workspaceType\": \"<detected type>\",\n           \"validationStatus\": \"valid\"\n         }\n         ```\n       - Log validation completion to `trace.log`\n    3. **Handle Validation Failure:**\n       - If validation fails, set `validationCache.validationStatus` to `\"invalid\"`\n       - Report errors and stop execution\n    4. If `hasRole: true`, read and assume the persona from `role.md` (overlay onto my base persona)\n    5. Read `instructions.md` and evaluate it as a [Document]\n    6. Execute the instructions:\n       - If single operation: execute directly\n       - If multi-step playbook: invoke [ExecuteMultiStepWorkspace]\n       - If nested workspaces: invoke [ExecuteNestedWorkspaces]\n       - If hybrid: execute steps with nested workspace invocations\n    7. **Handle Execution Errors:**\n       - If errors occur during execution that suggest structural issues, set `validationCache.validationStatus` to `\"needs-revalidation\"`\n       - Report the error and suggest running [RevalidateWorkspace]\n    8. Write final outputs to workspace `output/` directory\n    9. Log completion to `trace.log`\n- **Output:** Execution results and deliverables in workspace output directory.",
      "attrs": {},
      "steps": [
        "**Purpose:** Execute a complete workspace, handling role assumption, instruction execution, and output management.",
        "**Input:** Path to workspace directory.",
        "**Steps:**",
        "**Check Validation Cache:**",
        "Read `.workspace` configuration",
        "If `validationCache.validated` is `true` and `validationCache.validationStatus` is `\"valid\"`:",
        "Skip to step 4 using cached `validationCache.workspaceType`",
        "Log cache hit to `trace.log`",
        "Otherwise, proceed to step 2",
        "**Validate and Parse** (first-time only):",
        "Validate the workspace structure using [ValidateWorkspace](../core/workspace.busy.md#validateworkspace)",
        "Parse the `.workspace` configuration using [ParseWorkspaceConfig](../core/workspace.busy.md#parseworkspaceconfig)",
        "Determine workspace type using [DetectWorkspaceType](../core/workspace.busy.md#detectworkspacetype)",
        "Update `.workspace` file with validation cache: ```json \"validationCache\": { \"validated\": true, \"timestamp\": \"<current ISO timestamp>\", \"workspaceType\": \"<detected type>\", \"validationStatus\": \"valid\" } ```",
        "Log validation completion to `trace.log`",
        "**Handle Validation Failure:**",
        "If validation fails, set `validationCache.validationStatus` to `\"invalid\"`",
        "Report errors and stop execution",
        "If `hasRole: true`, read and assume the persona from `role.md` (overlay onto my base persona)",
        "Read `instructions.md` and evaluate it as a [Document]",
        "Execute the instructions:",
        "If single operation: execute directly",
        "If multi-step playbook: invoke [ExecuteMultiStepWorkspace]",
        "If nested workspaces: invoke [ExecuteNestedWorkspaces]",
        "If hybrid: execute steps with nested workspace invocations",
        "**Handle Execution Errors:**",
        "If errors occur during execution that suggest structural issues, set `validationCache.validationStatus` to `\"needs-revalidation\"`",
        "Report the error and suggest running [RevalidateWorkspace]",
        "Write final outputs to workspace `output/` directory",
        "Log completion to `trace.log`",
        "**Output:** Execution results and deliverables in workspace output directory."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Playbook": {
        "docId": "playbook"
      }
    }
  },
  "workspace_agent#executemultistepworkspace": {
    "operation": {
      "ref": "workspace_agent#executemultistepworkspace",
      "title": "ExecuteMultiStepWorkspace",
      "content": "- **Purpose:** Execute a multi-step workspace playbook with proper input/output chaining.\n- **Input:** Parsed workspace configuration and step folder list.\n- **Steps:**\n    1. Identify all step folders in sequence (step-1-*, step-2-*, etc.)\n    2. For each step in order:\n       a. Log step start to `trace.log`\n       b. Determine input source:\n          - First step: use parent workspace `input/`\n          - Other steps: use previous step's `deliverable.md`\n       c. Copy/reference input into step's `input/` directory\n       d. If step has its own `.workspace`, invoke [ExecuteWorkspace] recursively\n       e. Otherwise, execute step's `instructions.md` directly\n       f. Write step output to step's `output/` directory\n       g. Write step deliverable to step's `deliverable.md`\n       h. Log step completion to `trace.log`\n    3. Copy final step output to parent workspace `output/` directory\n- **Output:** Completed execution with all step deliverables and final output.",
      "attrs": {},
      "steps": [
        "**Purpose:** Execute a multi-step workspace playbook with proper input/output chaining.",
        "**Input:** Parsed workspace configuration and step folder list.",
        "**Steps:**",
        "Identify all step folders in sequence (step-1-*, step-2-*, etc.)",
        "For each step in order: a. Log step start to `trace.log` b. Determine input source:",
        "First step: use parent workspace `input/`",
        "Other steps: use previous step's `deliverable.md` c. Copy/reference input into step's `input/` directory d. If step has its own `.workspace`, invoke [ExecuteWorkspace] recursively e. Otherwise, execute step's `instructions.md` directly f. Write step output to step's `output/` directory g. Write step deliverable to step's `deliverable.md` h. Log step completion to `trace.log`",
        "Copy final step output to parent workspace `output/` directory",
        "**Output:** Completed execution with all step deliverables and final output."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Playbook": {
        "docId": "playbook"
      }
    }
  },
  "workspace_agent#executenestedworkspaces": {
    "operation": {
      "ref": "workspace_agent#executenestedworkspaces",
      "title": "ExecuteNestedWorkspaces",
      "content": "- **Purpose:** Invoke and manage nested workspace execution.\n- **Input:** List of nested workspaces from configuration.\n- **Steps:**\n    1. For each nested workspace in `nestedWorkspaces` array:\n       a. Log nested workspace invocation to `trace.log`\n       b. Change to nested workspace directory\n       c. Execute nested workspace using command template from configuration\n       d. Wait for nested workspace completion (synchronous)\n       e. Collect results from nested workspace `output/`\n       f. Return to parent workspace directory\n       g. Log nested workspace completion to `trace.log`\n    2. Aggregate results from all nested workspaces\n- **Output:** Aggregated results from all nested workspace executions.",
      "attrs": {},
      "steps": [
        "**Purpose:** Invoke and manage nested workspace execution.",
        "**Input:** List of nested workspaces from configuration.",
        "**Steps:**",
        "For each nested workspace in `nestedWorkspaces` array: a. Log nested workspace invocation to `trace.log` b. Change to nested workspace directory c. Execute nested workspace using command template from configuration d. Wait for nested workspace completion (synchronous) e. Collect results from nested workspace `output/` f. Return to parent workspace directory g. Log nested workspace completion to `trace.log`",
        "Aggregate results from all nested workspaces",
        "**Output:** Aggregated results from all nested workspace executions."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Playbook": {
        "docId": "playbook"
      }
    }
  },
  "workspace_agent#assumeworkspacerole": {
    "operation": {
      "ref": "workspace_agent#assumeworkspacerole",
      "title": "AssumeWorkspaceRole",
      "content": "- **Purpose:** Read and adopt the persona defined in a workspace's role.md file.\n- **Input:** Path to role.md file in workspace.\n- **Steps:**\n    1. Read the role.md file\n    2. Evaluate it as a [Role] [Document]\n    3. Extract [Persona], [Traits], [Principles], and [Skillset]\n    4. Merge the workspace role with my base Workspace Agent role:\n       - Adopt workspace role's persona for communication style\n       - Add workspace role's traits to my existing traits\n       - Prepend workspace role's principles to my principles\n       - Combine workspace role's skillset with my workspace execution skills\n    5. Log role assumption to `trace.log`\n    6. Operate under the merged role context for the duration of workspace execution\n- **Output:** Merged role context for workspace execution.",
      "attrs": {},
      "steps": [
        "**Purpose:** Read and adopt the persona defined in a workspace's role.md file.",
        "**Input:** Path to role.md file in workspace.",
        "**Steps:**",
        "Read the role.md file",
        "Evaluate it as a [Role] [Document]",
        "Extract [Persona], [Traits], [Principles], and [Skillset]",
        "Merge the workspace role with my base Workspace Agent role:",
        "Adopt workspace role's persona for communication style",
        "Add workspace role's traits to my existing traits",
        "Prepend workspace role's principles to my principles",
        "Combine workspace role's skillset with my workspace execution skills",
        "Log role assumption to `trace.log`",
        "Operate under the merged role context for the duration of workspace execution",
        "**Output:** Merged role context for workspace execution."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Playbook": {
        "docId": "playbook"
      }
    }
  },
  "workspace_agent#logexecution": {
    "operation": {
      "ref": "workspace_agent#logexecution",
      "title": "LogExecution",
      "content": "- **Purpose:** Log execution steps to trace.log following BUSY trace format.\n- **Input:** Timestamp, document/role name, operation name, message.\n- **Steps:**\n    1. Format log entry: `timestamp | Document -> Operation | message`\n    2. Append entry to workspace `trace.log` file\n    3. If detailed tracing enabled, write additional details to `.trace/` directory\n- **Output:** Log entry written to trace.log.",
      "attrs": {},
      "steps": [
        "**Purpose:** Log execution steps to trace.log following BUSY trace format.",
        "**Input:** Timestamp, document/role name, operation name, message.",
        "**Steps:**",
        "Format log entry: `timestamp | Document -> Operation | message`",
        "Append entry to workspace `trace.log` file",
        "If detailed tracing enabled, write additional details to `.trace/` directory",
        "**Output:** Log entry written to trace.log."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Playbook": {
        "docId": "playbook"
      }
    }
  },
  "workspace_agent#validatebeforeexecution": {
    "operation": {
      "ref": "workspace_agent#validatebeforeexecution",
      "title": "ValidateBeforeExecution",
      "content": "- **Purpose:** Perform pre-flight validation of workspace structure before execution.\n- **Input:** Workspace directory path.\n- **Steps:**\n    1. Invoke [ValidateWorkspace](../core/workspace.busy.md#validateworkspace)\n    2. Check for common issues:\n       - Missing required files (instructions.md, .workspace)\n       - Invalid JSON in .workspace file\n       - Missing role.md when hasRole is true\n       - Missing step folders when hasSteps is true\n       - Invalid step folder naming\n       - Missing standard directories (input/, output/, .trace/)\n    3. If validation fails, report specific errors clearly\n    4. If validation passes, proceed with execution\n- **Output:** Validation report with pass/fail status and any errors.",
      "attrs": {},
      "steps": [
        "**Purpose:** Perform pre-flight validation of workspace structure before execution.",
        "**Input:** Workspace directory path.",
        "**Steps:**",
        "Invoke [ValidateWorkspace](../core/workspace.busy.md#validateworkspace)",
        "Check for common issues:",
        "Missing required files (instructions.md, .workspace)",
        "Invalid JSON in .workspace file",
        "Missing role.md when hasRole is true",
        "Missing step folders when hasSteps is true",
        "Invalid step folder naming",
        "Missing standard directories (input/, output/, .trace/)",
        "If validation fails, report specific errors clearly",
        "If validation passes, proceed with execution",
        "**Output:** Validation report with pass/fail status and any errors."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Playbook": {
        "docId": "playbook"
      }
    }
  },
  "workspace_agent#revalidateworkspace": {
    "operation": {
      "ref": "workspace_agent#revalidateworkspace",
      "title": "RevalidateWorkspace",
      "content": "- **Purpose:** Force revalidation of workspace structure and update the validation cache. Use when execution errors suggest structural issues or when workspace files have been modified.\n- **Input:** Workspace directory path.\n- **Steps:**\n    1. Log revalidation request to `trace.log`\n    2. Clear existing validation cache by setting `validationCache.validationStatus` to `\"needs-revalidation\"`\n    3. Run full validation using [ValidateWorkspace](../core/workspace.busy.md#validateworkspace)\n    4. Parse configuration using [ParseWorkspaceConfig](../core/workspace.busy.md#parseworkspaceconfig)\n    5. Detect workspace type using [DetectWorkspaceType](../core/workspace.busy.md#detectworkspacetype)\n    6. Update `.workspace` file with new validation cache:\n       ```json\n       \"validationCache\": {\n         \"validated\": true,\n         \"timestamp\": \"<current ISO timestamp>\",\n         \"workspaceType\": \"<detected type>\",\n         \"validationStatus\": \"valid\"\n       }\n       ```\n    7. If validation fails, set `validationCache.validationStatus` to `\"invalid\"`\n    8. Report validation results\n    9. Log revalidation completion to `trace.log`\n- **Output:** Updated validation cache and validation report.",
      "attrs": {},
      "steps": [
        "**Purpose:** Force revalidation of workspace structure and update the validation cache. Use when execution errors suggest structural issues or when workspace files have been modified.",
        "**Input:** Workspace directory path.",
        "**Steps:**",
        "Log revalidation request to `trace.log`",
        "Clear existing validation cache by setting `validationCache.validationStatus` to `\"needs-revalidation\"`",
        "Run full validation using [ValidateWorkspace](../core/workspace.busy.md#validateworkspace)",
        "Parse configuration using [ParseWorkspaceConfig](../core/workspace.busy.md#parseworkspaceconfig)",
        "Detect workspace type using [DetectWorkspaceType](../core/workspace.busy.md#detectworkspacetype)",
        "Update `.workspace` file with new validation cache: ```json \"validationCache\": { \"validated\": true, \"timestamp\": \"<current ISO timestamp>\", \"workspaceType\": \"<detected type>\", \"validationStatus\": \"valid\" } ```",
        "If validation fails, set `validationCache.validationStatus` to `\"invalid\"`",
        "Report validation results",
        "Log revalidation completion to `trace.log`",
        "**Output:** Updated validation cache and validation report."
      ],
      "checklist": [
        "Workspace structure validated before execution",
        "Workspace configuration parsed correctly",
        "Role.md assumed if present (logged to trace.log)",
        "Instructions.md read and evaluated as BUSY Document",
        "All operations executed in correct order",
        "Input/output flow managed correctly (especially for multi-step)",
        "Nested workspaces invoked and completed (if applicable)",
        "Final outputs written to workspace output/ directory",
        "All execution steps logged to trace.log",
        "Workspace execution completed successfully"
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Playbook": {
        "docId": "playbook"
      }
    }
  },
  "workspace_architect#analyzeworkflow": {
    "operation": {
      "ref": "workspace_architect#analyzeworkflow",
      "title": "AnalyzeWorkflow",
      "content": "- **Purpose:** Understand the user's workflow or problem and identify workspace requirements.\n- **Steps:**\n    1. Analyze the user's description of their workflow or problem\n    2. Infer key details from context (document any assumptions):\n       - What are the inputs and outputs?\n       - What are the main steps or phases?\n       - Are there independent parallel tasks or sequential dependencies?\n       - Are there reusable components that could be nested workspaces?\n       - Does the agent need a specific persona or constraints?\n    3. Identify BUSY concepts that apply ([Document], [Operation], [Playbook], [Role])\n    4. Note any existing BUSY assets that can be referenced or reused\n    5. Make reasonable assumptions for missing information based on best practices\n- **Output:** Workflow understanding, key requirements, design assumptions, applicable BUSY concepts, recommended approach with rationale",
      "attrs": {},
      "steps": [
        "**Purpose:** Understand the user's workflow or problem and identify workspace requirements.",
        "**Steps:**",
        "Analyze the user's description of their workflow or problem",
        "Infer key details from context (document any assumptions):",
        "What are the inputs and outputs?",
        "What are the main steps or phases?",
        "Are there independent parallel tasks or sequential dependencies?",
        "Are there reusable components that could be nested workspaces?",
        "Does the agent need a specific persona or constraints?",
        "Identify BUSY concepts that apply ([Document], [Operation], [Playbook], [Role])",
        "Note any existing BUSY assets that can be referenced or reused",
        "Make reasonable assumptions for missing information based on best practices",
        "**Output:** Workflow understanding, key requirements, design assumptions, applicable BUSY concepts, recommended approach with rationale"
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Operation": {
        "docId": "operation"
      },
      "Document": {
        "docId": "document"
      },
      "BasicWorkspacePlaybook": {
        "docId": "build_basic_workspace_playbook"
      }
    }
  },
  "workspace_architect#designworkspacestructure": {
    "operation": {
      "ref": "workspace_architect#designworkspacestructure",
      "title": "DesignWorkspaceStructure",
      "content": "- **Purpose:** Design the optimal workspace structure based on analysis.\n- **Steps:**\n    1. Determine workspace type:\n       - **Single Operation**: Simple task with one clear operation\n       - **Multi-Step Playbook**: Sequential phases with dependencies\n       - **Nested Workspaces**: Independent components with separate contexts\n       - **Hybrid**: Multi-step with nested workspaces at certain steps\n    2. Design the workspace configuration:\n       - Choose workspace name (descriptive, kebab-case)\n       - Set framework (default: \"claude\")\n       - Determine if role context is needed (`hasRole`)\n       - Determine if multi-step structure is needed (`hasSteps`)\n       - Specify input/output sources\n    3. Map out the structure:\n       - For single operation: Define the main operation\n       - For multi-step: Define each step's purpose and deliverable\n       - For nested workspaces: Define each nested workspace's scope\n    4. Design role context (if needed):\n       - Define persona and expertise\n       - Specify constraints and guidelines\n       - Set tone and communication style\n    5. Make reasonable assumptions for any unspecified design choices\n- **Output:** Workspace type with rationale, configuration design (.workspace JSON), structure breakdown, role context design (if applicable), design assumptions with rationale",
      "attrs": {},
      "steps": [
        "**Purpose:** Design the optimal workspace structure based on analysis.",
        "**Steps:**",
        "Determine workspace type:",
        "**Single Operation**: Simple task with one clear operation",
        "**Multi-Step Playbook**: Sequential phases with dependencies",
        "**Nested Workspaces**: Independent components with separate contexts",
        "**Hybrid**: Multi-step with nested workspaces at certain steps",
        "Design the workspace configuration:",
        "Choose workspace name (descriptive, kebab-case)",
        "Set framework (default: \"claude\")",
        "Determine if role context is needed (`hasRole`)",
        "Determine if multi-step structure is needed (`hasSteps`)",
        "Specify input/output sources",
        "Map out the structure:",
        "For single operation: Define the main operation",
        "For multi-step: Define each step's purpose and deliverable",
        "For nested workspaces: Define each nested workspace's scope",
        "Design role context (if needed):",
        "Define persona and expertise",
        "Specify constraints and guidelines",
        "Set tone and communication style",
        "Make reasonable assumptions for any unspecified design choices",
        "**Output:** Workspace type with rationale, configuration design (.workspace JSON), structure breakdown, role context design (if applicable), design assumptions with rationale"
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Operation": {
        "docId": "operation"
      },
      "Document": {
        "docId": "document"
      },
      "BasicWorkspacePlaybook": {
        "docId": "build_basic_workspace_playbook"
      }
    }
  },
  "workspace_architect#specifyoperations": {
    "operation": {
      "ref": "workspace_architect#specifyoperations",
      "title": "SpecifyOperations",
      "content": "- **Purpose:** Define the operations that will execute within the workspace.\n- **Steps:**\n    1. For each identified step or component:\n       - Name the operation clearly (verb-noun format)\n       - Define inputs (from where: parent input, previous step, etc.)\n       - Define steps (what the operation does)\n       - Define outputs (deliverables, intermediate results)\n       - Add checklist items for validation\n    2. Identify reusable BUSY operations to reference\n    3. Determine which operations should be private (prefixed with `_`)\n    4. Document operation dependencies and execution order\n    5. Make reasonable assumptions about operation details based on best practices\n- **Output:** Operations with clear names and purposes, input/output flow, dependencies and execution order, reusable BUSY assets referenced, design assumptions with rationale",
      "attrs": {},
      "steps": [
        "**Purpose:** Define the operations that will execute within the workspace.",
        "**Steps:**",
        "For each identified step or component:",
        "Name the operation clearly (verb-noun format)",
        "Define inputs (from where: parent input, previous step, etc.)",
        "Define steps (what the operation does)",
        "Define outputs (deliverables, intermediate results)",
        "Add checklist items for validation",
        "Identify reusable BUSY operations to reference",
        "Determine which operations should be private (prefixed with `_`)",
        "Document operation dependencies and execution order",
        "Make reasonable assumptions about operation details based on best practices",
        "**Output:** Operations with clear names and purposes, input/output flow, dependencies and execution order, reusable BUSY assets referenced, design assumptions with rationale"
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Operation": {
        "docId": "operation"
      },
      "Document": {
        "docId": "document"
      },
      "BasicWorkspacePlaybook": {
        "docId": "build_basic_workspace_playbook"
      }
    }
  },
  "workspace_architect#createworkspacedesign": {
    "operation": {
      "ref": "workspace_architect#createworkspacedesign",
      "title": "CreateWorkspaceDesign",
      "content": "- **Purpose:** Document the complete workspace design for review and execution.\n- **Steps:**\n    1. Create a design document including:\n       - Workspace name and purpose\n       - `.workspace` configuration (JSON)\n       - Directory structure diagram (flat structure: all BUSY docs at root)\n       - **Content ownership mapping** (which file owns which content)\n       - Step breakdown (if multi-step)\n       - Nested workspace descriptions (if applicable)\n       - Role definition (if applicable) — TO BE PLACED IN: role.md (at root)\n       - Operation specifications — TO BE PLACED IN: operations.md (at root)\n       - Playbook flow — TO BE PLACED IN: playbook.md (at root)\n       - Input/output flow diagram — TO BE PLACED IN: operations.md or playbook.md\n    2. Apply Content Ownership Matrix and Flat Structure Principle to prevent redundancy\n    3. Review design against [Workspace] validation requirements\n    4. Verify instructions.md is kept minimal (API definition / navigation hub only, 40-80 lines)\n    5. **Document all design assumptions** - clearly state any decisions made without explicit user input\n    6. Provide complete, implementation-ready design (not a draft requiring iteration)\n- **Output:** Complete design documentation ready for implementation, validation checklist results, design assumptions with rationale, design decisions and trade-offs explained, alternative approaches considered (if applicable), next steps for implementation",
      "attrs": {},
      "steps": [
        "**Purpose:** Document the complete workspace design for review and execution.",
        "**Steps:**",
        "Create a design document including:",
        "Workspace name and purpose",
        "`.workspace` configuration (JSON)",
        "Directory structure diagram (flat structure: all BUSY docs at root)",
        "**Content ownership mapping** (which file owns which content)",
        "Step breakdown (if multi-step)",
        "Nested workspace descriptions (if applicable)",
        "Role definition (if applicable) — TO BE PLACED IN: role.md (at root)",
        "Operation specifications — TO BE PLACED IN: operations.md (at root)",
        "Playbook flow — TO BE PLACED IN: playbook.md (at root)",
        "Input/output flow diagram — TO BE PLACED IN: operations.md or playbook.md",
        "Apply Content Ownership Matrix and Flat Structure Principle to prevent redundancy",
        "Review design against [Workspace] validation requirements",
        "Verify instructions.md is kept minimal (API definition / navigation hub only, 40-80 lines)",
        "**Document all design assumptions** - clearly state any decisions made without explicit user input",
        "Provide complete, implementation-ready design (not a draft requiring iteration)",
        "**Output:** Complete design documentation ready for implementation, validation checklist results, design assumptions with rationale, design decisions and trade-offs explained, alternative approaches considered (if applicable), next steps for implementation"
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Operation": {
        "docId": "operation"
      },
      "Document": {
        "docId": "document"
      },
      "BasicWorkspacePlaybook": {
        "docId": "build_basic_workspace_playbook"
      }
    }
  },
  "workspace_architect#executeworkspacecreation": {
    "operation": {
      "ref": "workspace_architect#executeworkspacecreation",
      "title": "ExecuteWorkspaceCreation",
      "content": "- **Purpose:** Use the [BasicWorkspacePlaybook] to materialize the workspace design.\n- **Steps:**\n    1. Prepare execution context:\n       - Set target directory for workspace\n       - Gather any template files or assets\n       - Prepare role definition if needed\n    2. Execute [BasicWorkspacePlaybook] using `/busy:playbook:execute-playbook`\n    3. Customize generated files:\n       - Update `instructions.md` with designed operations\n       - Create `role.md` if role context specified\n       - Configure step folders if multi-step design\n       - Set up nested workspaces if hybrid design\n    4. Validate created workspace against design\n    5. Provide user with:\n       - Workspace location and structure\n       - Instructions for using the workspace\n       - Next steps for customization",
      "attrs": {},
      "steps": [
        "**Purpose:** Use the [BasicWorkspacePlaybook] to materialize the workspace design.",
        "**Steps:**",
        "Prepare execution context:",
        "Set target directory for workspace",
        "Gather any template files or assets",
        "Prepare role definition if needed",
        "Execute [BasicWorkspacePlaybook] using `/busy:playbook:execute-playbook`",
        "Customize generated files:",
        "Update `instructions.md` with designed operations",
        "Create `role.md` if role context specified",
        "Configure step folders if multi-step design",
        "Set up nested workspaces if hybrid design",
        "Validate created workspace against design",
        "Provide user with:",
        "Workspace location and structure",
        "Instructions for using the workspace",
        "Next steps for customization"
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Operation": {
        "docId": "operation"
      },
      "Document": {
        "docId": "document"
      },
      "BasicWorkspacePlaybook": {
        "docId": "build_basic_workspace_playbook"
      }
    }
  },
  "workspace_architect#optimizeworkspace": {
    "operation": {
      "ref": "workspace_architect#optimizeworkspace",
      "title": "OptimizeWorkspace",
      "content": "- **Purpose:** Review and optimize existing workspace designs for efficiency and clarity.\n- **Steps:**\n    1. Analyze existing workspace:\n       - Review `.workspace` configuration\n       - Examine `instructions.md` and operations\n       - Check step structure and dependencies\n       - Assess nested workspace usage\n    2. Identify optimization opportunities:\n       - Overly complex structures that could be simplified\n       - Operations that could be broken down or combined\n       - Missing opportunities for reusable nested workspaces\n       - Unclear or missing role context\n    3. Propose optimizations with rationale\n    4. Implement approved optimizations\n    5. Re-validate against [Workspace] specifications",
      "attrs": {},
      "steps": [
        "**Purpose:** Review and optimize existing workspace designs for efficiency and clarity.",
        "**Steps:**",
        "Analyze existing workspace:",
        "Review `.workspace` configuration",
        "Examine `instructions.md` and operations",
        "Check step structure and dependencies",
        "Assess nested workspace usage",
        "Identify optimization opportunities:",
        "Overly complex structures that could be simplified",
        "Operations that could be broken down or combined",
        "Missing opportunities for reusable nested workspaces",
        "Unclear or missing role context",
        "Propose optimizations with rationale",
        "Implement approved optimizations",
        "Re-validate against [Workspace] specifications"
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Operation": {
        "docId": "operation"
      },
      "Document": {
        "docId": "document"
      },
      "BasicWorkspacePlaybook": {
        "docId": "build_basic_workspace_playbook"
      }
    }
  },
  "workspace_architect#provideguidance": {
    "operation": {
      "ref": "workspace_architect#provideguidance",
      "title": "ProvideGuidance",
      "content": "- **Purpose:** Educate users on workspace design best practices and BUSY concepts.\n- **Steps:**\n    1. Explain relevant BUSY concepts in context\n    2. Show examples of well-designed workspaces\n    3. Highlight patterns and anti-patterns\n    4. Provide decision frameworks:\n       - When to use multi-step vs. nested workspaces\n       - When to define a role context\n       - How to name operations effectively\n       - How to structure input/output flow\n    5. Point to relevant BUSY documentation\n\n**Example: Explaining the API Definition / Navigation Hub Pattern**\n\nWhen a user asks \"How detailed should instructions.md be?\", provide this guidance:\n\n\"instructions.md should be an **API definition**—a thin entry point that provides just enough context before deferring to downstream docs. Think of it as a navigation hub, not a content repository.\n\n**Good instructions.md** (API Definition):\n- Lists available operations with 1-line descriptions\n- References detail files at root level: 'See [Operations] for complete definitions'\n- Provides prerequisites and usage instructions\n- Total length: 40-80 lines for typical workspace\n- Uses flat structure: [Operations]:./operations.md, [Playbook]:./playbook.busy.md, [Role]:./role.busy.md\n\n**Bad instructions.md** (Kitchen Sink):\n- Duplicates operation steps from operations.md\n- Repeats role persona from role.md\n- Contains execution flow diagrams\n- Places playbooks in subdirectories (playbooks/*)\n- Total length: 130+ lines with heavy redundancy\n\n**Rule of thumb:** If instructions.md > 100 lines, you're probably duplicating content that belongs elsewhere.\n\n**Structure principle:** All BUSY documents at root level—no subdirectories for playbooks or operations.\"",
      "attrs": {},
      "steps": [
        "**Purpose:** Educate users on workspace design best practices and BUSY concepts.",
        "**Steps:**",
        "Explain relevant BUSY concepts in context",
        "Show examples of well-designed workspaces",
        "Highlight patterns and anti-patterns",
        "Provide decision frameworks:",
        "When to use multi-step vs. nested workspaces",
        "When to define a role context",
        "How to name operations effectively",
        "How to structure input/output flow",
        "Point to relevant BUSY documentation",
        "Lists available operations with 1-line descriptions",
        "References detail files at root level: 'See [Operations] for complete definitions'",
        "Provides prerequisites and usage instructions",
        "Total length: 40-80 lines for typical workspace",
        "Uses flat structure: [Operations]:./operations.md, [Playbook]:./playbook.busy.md, [Role]:./role.busy.md",
        "Duplicates operation steps from operations.md",
        "Repeats role persona from role.md",
        "Contains execution flow diagrams",
        "Places playbooks in subdirectories (playbooks/*)",
        "Total length: 130+ lines with heavy redundancy"
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Operation": {
        "docId": "operation"
      },
      "Document": {
        "docId": "document"
      },
      "BasicWorkspacePlaybook": {
        "docId": "build_basic_workspace_playbook"
      }
    }
  },
  "checklist#runchecklist": {
    "operation": {
      "ref": "checklist#runchecklist",
      "title": "RunChecklist",
      "content": "When a callable defines a [Checklist], the agent must:\n1. **Locate the Checklist:** After completing the main steps, identify the `Checklist` section and enumerate every [Checklist Item].\n2. **Verify Sequentially:** Address each item in order, gathering evidence or logs that demonstrate the outcome is satisfied. If an item cannot be verified, stop and return an [error] describing the gap.\n3. **Record Evidence:** Note how each verification was satisfied (e.g., test output, file diff, user confirmation) so downstream consumers understand the proof of completion.\n4. **Confirm Completion:** Once all items are verified, explicitly state that the [Checklist] has been completed and summarize any findings uncovered during verification.",
      "attrs": {},
      "steps": [
        "**Locate the Checklist:** After completing the main steps, identify the `Checklist` section and enumerate every [Checklist Item].",
        "**Verify Sequentially:** Address each item in order, gathering evidence or logs that demonstrate the outcome is satisfied. If an item cannot be verified, stop and return an [error] describing the gap.",
        "**Record Evidence:** Note how each verification was satisfied (e.g., test output, file diff, user confirmation) so downstream consumers understand the proof of completion.",
        "**Confirm Completion:** Once all items are verified, explicitly state that the [Checklist] has been completed and summarize any findings uncovered during verification."
      ],
      "checklist": [
        "All checklist items enumerated and verified in order.",
        "Evidence recorded for each item or an [error] returned specifying the missing verification.",
        "Final confirmation of checklist completion logged or reported to the caller."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Checklist": {
        "docId": "checklist",
        "slug": "checklist-section"
      },
      "Checklist Item": {
        "docId": "checklist",
        "slug": "checklist-item"
      },
      "error": {
        "docId": "operation",
        "slug": "error"
      }
    }
  },
  "concept#evaluateconcept": {
    "operation": {
      "ref": "concept#evaluateconcept",
      "title": "EvaluateConcept",
      "content": "When an LLM encounters a [Concept], it should:\n1.  **Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`).\n    *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*\n2.  **Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].\n3.  **Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.\n4.  **Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced.",
      "attrs": {},
      "steps": [
        "**Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`). *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*",
        "**Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].",
        "**Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.",
        "**Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      }
    }
  },
  "document#evaluatedocument": {
    "operation": {
      "ref": "document#evaluatedocument",
      "title": "EvaluateDocument",
      "content": "When an LLM processes a [Document], it should:\n1.  **Parse Frontmatter:** Extract `Name` and `Description` for contextual understanding.\n2.  **Process Imports:** Resolve all imported [Concept]s by following their links and integrating their definitions into the current context. If any import cannot be resolved (invalid path or anchor), immediately return an [error] describing the missing import and stop further processing; do not execute [Setup](./document.busy.md#setup-section) or later steps.\n3.  **Execute Setup:** Follow the instructions in the `# [Setup](./document.busy.md#setup-section)` section, establishing any required context, persona, or initial state. Persist any specified state to memory files.\n4.  **Enforce Strict Execution:** All defined [Operation]s MUST be executed precisely as their steps dictate, including any [Checklist] sections they define.\n5.  **Identify Operations:** Recognize all defined [Operation]s within the `# Operations` section, making them available for execution or reference.\n6.  **Log Document Context:** Record the [Document]'s name, description, processed imports, and established setup for traceability.",
      "attrs": {},
      "steps": [
        "**Parse Frontmatter:** Extract `Name` and `Description` for contextual understanding.",
        "**Process Imports:** Resolve all imported [Concept]s by following their links and integrating their definitions into the current context. If any import cannot be resolved (invalid path or anchor), immediately return an [error] describing the missing import and stop further processing; do not execute [Setup](./document.busy.md#setup-section) or later steps.",
        "**Execute Setup:** Follow the instructions in the `# [Setup](./document.busy.md#setup-section)` section, establishing any required context, persona, or initial state. Persist any specified state to memory files.",
        "**Enforce Strict Execution:** All defined [Operation]s MUST be executed precisely as their steps dictate, including any [Checklist] sections they define.",
        "**Identify Operations:** Recognize all defined [Operation]s within the `# Operations` section, making them available for execution or reference.",
        "**Log Document Context:** Record the [Document]'s name, description, processed imports, and established setup for traceability."
      ],
      "checklist": [
        "Frontmatter parsed and `Name`/`Description` captured.",
        "Imports resolved and integrated into context; unresolved imports produce a clear [error] and halt execution prior to Setup.",
        "Setup executed; any state persisted as specified.",
        "All Operations identified and made available.",
        "Document context logged (including resolved imports and setup notes)."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "Tool": {
        "docId": "tool"
      },
      "Playbook": {
        "docId": "playbook"
      }
    }
  },
  "document#listoperations": {
    "operation": {
      "ref": "document#listoperations",
      "title": "ListOperations",
      "content": "Parses the [Document] to find all defined [Operation]s under the `# Operations` section.",
      "attrs": {},
      "steps": [
        "Parse the document.",
        "Identify all `## Headings` under `# Operations`.",
        "Present the results to the user."
      ],
      "checklist": [
        "The output MUST be presented as a numbered list.",
        "Each number MUST correspond to an operation.",
        "The user MUST be able to invoke an operation by its number.",
        "Returns only operations defined under `# Operations`.",
        "Output formatted as a numbered list.",
        "Each item clearly maps to an invocable operation."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "Tool": {
        "docId": "tool"
      },
      "Playbook": {
        "docId": "playbook"
      }
    }
  },
  "operation#executeoperation": {
    "operation": {
      "ref": "operation#executeoperation",
      "title": "ExecuteOperation",
      "content": "When an LLM is instructed to execute an [Operation], it should:\n1.  **Identify Inputs:** Collect and identify the values of the [input] data or state required for the [Operation] to proceed. Log these [input]s and their sources.\n2.  **Search for Missing Inputs:** If required inputs are not explicitly provided, search the current context (e.g., parent [Document], memory files) for the necessary data. If you are unable to confidently identify any remaining [input]s required, then return an [error].\n3.  **Execute Steps:** Follow the defined steps or instructions within the [Operation]. **IMPORTANT: Follow each step strictly!** If you run into an unexpected issue, stop and return an [error]. If another [Operation] is referenced in the step [execute that operation](./operation.busy.md#executeoperation) in its own scope, providing any inputs it needs, then wait for it to return to proceed.\n4.  **Manage State:** If the [Operation] defines its own variables or state, store them appropriately (e.g., in memory files like AGENT.md, CLAUDE.md, GEMINI.md) for the duration of the [Operation] or as specified.\n5.  **Log Actions:** Record all significant actions taken, intermediate results, and final outcomes of the [Operation] for transparency and debugging.\n6.  **Handle Outputs:** If the [Operation] produces an [output], make it available to the calling context or store it as specified.\n7.  **Run Checklist:** If the [Operation] includes a [Checklist], execute [RunChecklist] before reporting success so every verification item is confirmed.",
      "attrs": {},
      "steps": [
        "**Identify Inputs:** Collect and identify the values of the [input] data or state required for the [Operation] to proceed. Log these [input]s and their sources.",
        "**Search for Missing Inputs:** If required inputs are not explicitly provided, search the current context (e.g., parent [Document], memory files) for the necessary data. If you are unable to confidently identify any remaining [input]s required, then return an [error].",
        "**Execute Steps:** Follow the defined steps or instructions within the [Operation]. **IMPORTANT: Follow each step strictly!** If you run into an unexpected issue, stop and return an [error]. If another [Operation] is referenced in the step [execute that operation](./operation.busy.md#executeoperation) in its own scope, providing any inputs it needs, then wait for it to return to proceed.",
        "**Manage State:** If the [Operation] defines its own variables or state, store them appropriately (e.g., in memory files like AGENT.md, CLAUDE.md, GEMINI.md) for the duration of the [Operation] or as specified.",
        "**Log Actions:** Record all significant actions taken, intermediate results, and final outcomes of the [Operation] for transparency and debugging.",
        "**Handle Outputs:** If the [Operation] produces an [output], make it available to the calling context or store it as specified.",
        "**Run Checklist:** If the [Operation] includes a [Checklist], execute [RunChecklist] before reporting success so every verification item is confirmed."
      ],
      "checklist": [
        "Inputs identified and their sources logged.",
        "Missing inputs searched for; unresolved requirements trigger a clear [error].",
        "Steps executed strictly in order; referenced operations executed in their own scope.",
        "State managed and persisted appropriately for the operation's duration.",
        "Significant actions and outcomes logged for traceability.",
        "Outputs handled per specification (returned or stored).",
        "Checklist (if present) executed via [RunChecklist] before completion."
      ]
    },
    "defs": [],
    "calls": [
      {
        "ref": "operation#executeoperation",
        "title": "ExecuteOperation"
      }
    ],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "RunChecklist": {
        "docId": "checklist",
        "slug": "runchecklist"
      },
      "input": {
        "docId": "operation",
        "slug": "input"
      },
      "output": {
        "docId": "operation",
        "slug": "output"
      },
      "error": {
        "docId": "operation",
        "slug": "error"
      }
    }
  },
  "playbook#executeplaybook": {
    "operation": {
      "ref": "playbook#executeplaybook",
      "title": "ExecutePlaybook",
      "content": "When instructed to run a [Playbook], do the following:\n1. **Evaluate Document:** Run [EvaluateDocument](./document.busy.md#evaluatedocument) to load setup, state, and private operations.\n2. **Identify Steps:** Parse the `# [Operations](./document.busy.md#operations-section)` section for non-private [Sequence Step] definitions (e.g., headings describing `Step 1`, `Step A`, etc.) or follow an explicit steps table if provided. Maintain the declared order.\n3. **Resolve Each Step:** For each step in order:\n   - Evaluate its [Condition] (if any). If the condition is false, skip the step and log the decision.\n   - If the step references a [Private Operation], execute it directly.\n   - Otherwise, locate the referenced callable (another [Operation], [Prompt], [Document], or [Tool]) and gather required inputs.\n   - If a [Role Context] is defined, invoke `ExecuteRole` for that role, run the callable, then restore the previous role/state.\n   - Capture outputs or state updates as directed by the step definition.\n4. **Handle Failures:** If any step cannot be resolved or produces an error, stop execution and return an [error](./operation.busy.md#error) that includes the step name and details.\n5. **Run Checklist:** After the main sequence completes, execute [RunChecklist] if the [Playbook] defines one so every verification item is confirmed.\n6. **Summarize Results:** After all steps succeed, provide a concise summary of actions performed and outputs produced.",
      "attrs": {},
      "steps": [
        "**Evaluate Document:** Run [EvaluateDocument](./document.busy.md#evaluatedocument) to load setup, state, and private operations.",
        "**Identify Steps:** Parse the `# [Operations](./document.busy.md#operations-section)` section for non-private [Sequence Step] definitions (e.g., headings describing `Step 1`, `Step A`, etc.) or follow an explicit steps table if provided. Maintain the declared order.",
        "**Resolve Each Step:** For each step in order:",
        "Evaluate its [Condition] (if any). If the condition is false, skip the step and log the decision.",
        "If the step references a [Private Operation], execute it directly.",
        "Otherwise, locate the referenced callable (another [Operation], [Prompt], [Document], or [Tool]) and gather required inputs.",
        "If a [Role Context] is defined, invoke `ExecuteRole` for that role, run the callable, then restore the previous role/state.",
        "Capture outputs or state updates as directed by the step definition.",
        "**Handle Failures:** If any step cannot be resolved or produces an error, stop execution and return an [error](./operation.busy.md#error) that includes the step name and details.",
        "**Run Checklist:** After the main sequence completes, execute [RunChecklist] if the [Playbook] defines one so every verification item is confirmed.",
        "**Summarize Results:** After all steps succeed, provide a concise summary of actions performed and outputs produced."
      ],
      "checklist": [
        "Document evaluated; private operations loaded.",
        "All steps resolved or skipped based on conditions with reasons logged.",
        "Failures reported with step names and details; execution halted appropriately.",
        "Checklist (if defined) executed after main sequence.",
        "Final summary produced and logged."
      ]
    },
    "defs": [],
    "calls": [
      {
        "ref": "document#evaluatedocument",
        "title": "EvaluateDocument"
      }
    ],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "Role": {
        "docId": "role"
      },
      "Tool": {
        "docId": "tool"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "RunChecklist": {
        "docId": "checklist",
        "slug": "runchecklist"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Sequence Step": {
        "docId": "playbook",
        "slug": "sequence-step"
      },
      "Condition": {
        "docId": "playbook",
        "slug": "condition"
      },
      "Role Context": {
        "docId": "playbook",
        "slug": "role-context"
      },
      "Private Operation": {
        "docId": "playbook",
        "slug": "private-operation"
      },
      "ExecutePlaybook": {
        "docId": "playbook",
        "slug": "executeplaybook"
      },
      "ListPlaybookSteps": {
        "docId": "playbook",
        "slug": "listplaybooksteps"
      }
    }
  },
  "playbook#listplaybooksteps": {
    "operation": {
      "ref": "playbook#listplaybooksteps",
      "title": "ListPlaybookSteps",
      "content": "Enumerate the discrete [Sequence Step]s in this [Playbook].\n1. Parse the [Playbook] after [EvaluateDocument].\n2. Collect step headings (excluding [Private Operation]s) in execution order.\n3. Present the list as a numbered outline including the target callable and any role context.",
      "attrs": {},
      "steps": [
        "Parse the [Playbook] after [EvaluateDocument].",
        "Collect step headings (excluding [Private Operation]s) in execution order.",
        "Present the list as a numbered outline including the target callable and any role context."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "Role": {
        "docId": "role"
      },
      "Tool": {
        "docId": "tool"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "RunChecklist": {
        "docId": "checklist",
        "slug": "runchecklist"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Sequence Step": {
        "docId": "playbook",
        "slug": "sequence-step"
      },
      "Condition": {
        "docId": "playbook",
        "slug": "condition"
      },
      "Role Context": {
        "docId": "playbook",
        "slug": "role-context"
      },
      "Private Operation": {
        "docId": "playbook",
        "slug": "private-operation"
      },
      "ExecutePlaybook": {
        "docId": "playbook",
        "slug": "executeplaybook"
      },
      "ListPlaybookSteps": {
        "docId": "playbook",
        "slug": "listplaybooksteps"
      }
    }
  },
  "prompt#executeprompt": {
    "operation": {
      "ref": "prompt#executeprompt",
      "title": "ExecutePrompt",
      "content": "When an LLM executes a [Prompt], it should:\n1.  **Evaluate as Document:** First, process the [Prompt] as a standard [Document] by following the [EvaluateDocument](./document.busy.md#evaluatedocument) [Operation] defined in [Document].\n2.  **Interpret Goal:** Review the [prompt text] and any other sections provided to understand the overarching objective or question posed by the [Prompt].\n3.  **Orchestrate Operations:** Based on the [prompt text], goal, and the available [Concept]s and [Operation]s (both imported, inferred, and defined within the [Prompt]), determine the sequence of actions to take.\n4.  **Execute Defined Operations:** Systematically execute the [Operation]s defined within its `# [Operations](./document.busy.md#operations-section)` section, or imported or inferred [Operation]s, as needed to fulfill the prompt's objective.\n5.  **Synthesize Response:** Combine the results of executed [Operation]s and the overall context to formulate a comprehensive and coherent response or output.\n6.  **Log Execution Flow:** Maintain a detailed log of the entire execution flow, including which [Document]s, [Concept]s, and [Operation]s were utilized, and their outcomes.",
      "attrs": {},
      "steps": [
        "**Evaluate as Document:** First, process the [Prompt] as a standard [Document] by following the [EvaluateDocument](./document.busy.md#evaluatedocument) [Operation] defined in [Document].",
        "**Interpret Goal:** Review the [prompt text] and any other sections provided to understand the overarching objective or question posed by the [Prompt].",
        "**Orchestrate Operations:** Based on the [prompt text], goal, and the available [Concept]s and [Operation]s (both imported, inferred, and defined within the [Prompt]), determine the sequence of actions to take.",
        "**Execute Defined Operations:** Systematically execute the [Operation]s defined within its `# [Operations](./document.busy.md#operations-section)` section, or imported or inferred [Operation]s, as needed to fulfill the prompt's objective.",
        "**Synthesize Response:** Combine the results of executed [Operation]s and the overall context to formulate a comprehensive and coherent response or output.",
        "**Log Execution Flow:** Maintain a detailed log of the entire execution flow, including which [Document]s, [Concept]s, and [Operation]s were utilized, and their outcomes."
      ],
      "checklist": [
        "Evaluated as a [Document] and [Setup](./document.busy.md#setup-section) completed.",
        "Goal interpreted from [prompt text] and context.",
        "Necessary operations orchestrated and executed in order.",
        "Final response synthesized and returned.",
        "Execution flow logged with key actions and results."
      ]
    },
    "defs": [],
    "calls": [
      {
        "ref": "document#evaluatedocument",
        "title": "EvaluateDocument"
      }
    ],
    "symbols": {
      "Document": {
        "docId": "document"
      },
      "Concept": {
        "docId": "concept"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "prompt text": {
        "docId": "prompt",
        "slug": "prompt-text"
      },
      "Operations": {
        "docId": "document",
        "slug": "operations-section"
      }
    }
  },
  "role#executerole": {
    "operation": {
      "ref": "role#executerole",
      "title": "ExecuteRole",
      "content": "This is the primary [Operation] for a [Role] [Document]. It determines the [Role]'s behavior based on the execution context.\n\n1.  **Assume Persona:** First, process the [Role] as a standard [Document] by following the [EvaluateDocument](./document.busy.md#evaluatedocument) [Operation]. This includes executing the `# [Setup](./document.busy.md#setup-section)` section to internalize the [Persona], [Traits], and [Principles]. Log the assumption of the [Role].\n2.  **Check for Incoming Task:** Determine if a specific [Prompt] or [Operation] was provided alongside the [Role] invocation, or if a more implicit/unstructured task was requested. If the latter, be sure to infer the task and map it into the conceptual structure of an [Operation]. If you are unable to do so without removing ambiguity, then return an [error](./operation.busy.md#error).\n3.  **Execute Task (if provided):** If an incoming task exists, the [Role] seamlessly proceeds to execute that [Prompt] or [Operation], applying its unique [Persona] and [Skillset] to the task at hand.\n4.  **Introduce Self (if no task):** If the [Role] was executed without a specific task, it must greet the user in character, introduce itself, and present a \"menu\" of the [Operation]s it is capable of performing by invoking the [ListOperations](./document.busy.md#listoperations) [Operation].",
      "attrs": {},
      "steps": [
        "**Assume Persona:** First, process the [Role] as a standard [Document] by following the [EvaluateDocument](./document.busy.md#evaluatedocument) [Operation]. This includes executing the `# [Setup](./document.busy.md#setup-section)` section to internalize the [Persona], [Traits], and [Principles]. Log the assumption of the [Role].",
        "**Check for Incoming Task:** Determine if a specific [Prompt] or [Operation] was provided alongside the [Role] invocation, or if a more implicit/unstructured task was requested. If the latter, be sure to infer the task and map it into the conceptual structure of an [Operation]. If you are unable to do so without removing ambiguity, then return an [error](./operation.busy.md#error).",
        "**Execute Task (if provided):** If an incoming task exists, the [Role] seamlessly proceeds to execute that [Prompt] or [Operation], applying its unique [Persona] and [Skillset] to the task at hand.",
        "**Introduce Self (if no task):** If the [Role] was executed without a specific task, it must greet the user in character, introduce itself, and present a \"menu\" of the [Operation]s it is capable of performing by invoking the [ListOperations](./document.busy.md#listoperations) [Operation]."
      ],
      "checklist": [
        "[Persona] assumed ([Traits] and [Principles] internalized) and logged.",
        "If a task was provided: executed the task under the role context; otherwise presented a concise menu of available [Operation]s.",
        "Any state or outputs produced are clearly attributed to this [Role]."
      ]
    },
    "defs": [],
    "calls": [
      {
        "ref": "document#evaluatedocument",
        "title": "EvaluateDocument"
      },
      {
        "ref": "document#listoperations",
        "title": "ListOperations"
      }
    ],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "Role": {
        "docId": "role"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "Persona": {
        "docId": "role",
        "slug": "persona"
      },
      "Traits": {
        "docId": "role",
        "slug": "traits"
      },
      "Principles": {
        "docId": "role",
        "slug": "principles"
      },
      "Skillset": {
        "docId": "role",
        "slug": "skillset"
      }
    }
  },
  "tool#invoketool": {
    "operation": {
      "ref": "tool#invoketool",
      "title": "InvokeTool",
      "content": "When an LLM is asked to run a [Tool], it should:\n1.  **Evaluate Document:** Follow [EvaluateDocument](./document.busy.md#evaluatedocument) to load the [Tool]'s setup and definitions.\n2.  **Collect Inputs:** Read the [Inputs] definition and the calling context to gather required values. If any are missing, pause and return an [error](./operation.busy.md#error) that lists what is needed.\n3.  **Prepare Invocation:** Use the [Invocation Contract] to assemble the command, MCP request, or script execution, substituting collected inputs and checking required environment variables or files.\n4.  **Execute or Simulate:** Carry out the call exactly as described. If execution is not possible in the current environment, produce a step-by-step plan or command snippet that the caller can run manually.\n5.  **Handle Outputs:** Store results according to the [Outputs] definition (e.g., write to an outbox file, append to a log). Confirm success criteria or raise an [error](./operation.busy.md#error) when the contract cannot be satisfied.",
      "attrs": {},
      "steps": [
        "**Evaluate Document:** Follow [EvaluateDocument](./document.busy.md#evaluatedocument) to load the [Tool]'s setup and definitions.",
        "**Collect Inputs:** Read the [Inputs] definition and the calling context to gather required values. If any are missing, pause and return an [error](./operation.busy.md#error) that lists what is needed.",
        "**Prepare Invocation:** Use the [Invocation Contract] to assemble the command, MCP request, or script execution, substituting collected inputs and checking required environment variables or files.",
        "**Execute or Simulate:** Carry out the call exactly as described. If execution is not possible in the current environment, produce a step-by-step plan or command snippet that the caller can run manually.",
        "**Handle Outputs:** Store results according to the [Outputs] definition (e.g., write to an outbox file, append to a log). Confirm success criteria or raise an [error](./operation.busy.md#error) when the contract cannot be satisfied."
      ],
      "checklist": [
        "Inputs collected and validated against [Inputs]; missing values reported via [error].",
        "Invocation assembled according to [Invocation Contract] (including env vars and files).",
        "Execution performed or a runnable plan provided with exact commands/request.",
        "Outputs stored in the declared locations and success criteria confirmed."
      ]
    },
    "defs": [],
    "calls": [
      {
        "ref": "document#evaluatedocument",
        "title": "EvaluateDocument"
      }
    ],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Tool": {
        "docId": "tool"
      },
      "Capability": {
        "docId": "tool",
        "slug": "capability"
      },
      "Invocation Contract": {
        "docId": "tool",
        "slug": "invocation-contract"
      },
      "Inputs": {
        "docId": "tool",
        "slug": "inputs"
      },
      "Outputs": {
        "docId": "tool",
        "slug": "outputs"
      },
      "State": {
        "docId": "tool",
        "slug": "state"
      },
      "InvokeTool": {
        "docId": "tool",
        "slug": "invoketool"
      },
      "DescribeCapability": {
        "docId": "tool",
        "slug": "describecapability"
      },
      "Checklist": {
        "docId": "checklist"
      }
    }
  },
  "tool#describecapability": {
    "operation": {
      "ref": "tool#describecapability",
      "title": "DescribeCapability",
      "content": "Summarize what the [Tool] does so other agents can decide when to invoke it.\n1.  Read the [Capability], [Inputs], and [Outputs] definitions.\n2.  Produce a short description that includes the action performed, required inputs, and primary output location.\n3.  Mention the execution mode (script, MCP, CLI, etc.) drawn from the [Invocation Contract].",
      "attrs": {},
      "steps": [
        "Read the [Capability], [Inputs], and [Outputs] definitions.",
        "Produce a short description that includes the action performed, required inputs, and primary output location.",
        "Mention the execution mode (script, MCP, CLI, etc.) drawn from the [Invocation Contract]."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Tool": {
        "docId": "tool"
      },
      "Capability": {
        "docId": "tool",
        "slug": "capability"
      },
      "Invocation Contract": {
        "docId": "tool",
        "slug": "invocation-contract"
      },
      "Inputs": {
        "docId": "tool",
        "slug": "inputs"
      },
      "Outputs": {
        "docId": "tool",
        "slug": "outputs"
      },
      "State": {
        "docId": "tool",
        "slug": "state"
      },
      "InvokeTool": {
        "docId": "tool",
        "slug": "invoketool"
      },
      "DescribeCapability": {
        "docId": "tool",
        "slug": "describecapability"
      },
      "Checklist": {
        "docId": "checklist"
      }
    }
  },
  "workspace#validateworkspace": {
    "operation": {
      "ref": "workspace#validateworkspace",
      "title": "ValidateWorkspace",
      "content": "Verify that a workspace conforms to the Workspace specification.\n\n**Input:**\n- Workspace directory path\n\n**Steps:**\n1. Check `.workspace` file exists and contains valid JSON\n2. Verify required fields: `name`, `type`, `version`, `framework`\n3. Verify `type` equals \"workspace\"\n4. Check `instructions.md` exists and has valid BUSY format\n5. Verify standard directories exist: `input/`, `output/`, `.trace/`\n6. If `hasRole: true`, verify `role.md` exists\n7. If `hasSteps: true`, verify step folders exist with proper structure\n8. If `nestedWorkspaces` array exists, verify each path and command\n9. Verify working files exist: `trace.log`, `memory.json`\n\n**Output:**\n- Validation report with pass/fail status\n- List of any validation errors or warnings",
      "attrs": {},
      "steps": [
        "Workspace directory path",
        "Check `.workspace` file exists and contains valid JSON",
        "Verify required fields: `name`, `type`, `version`, `framework`",
        "Verify `type` equals \"workspace\"",
        "Check `instructions.md` exists and has valid BUSY format",
        "Verify standard directories exist: `input/`, `output/`, `.trace/`",
        "If `hasRole: true`, verify `role.md` exists",
        "If `hasSteps: true`, verify step folders exist with proper structure",
        "If `nestedWorkspaces` array exists, verify each path and command",
        "Verify working files exist: `trace.log`, `memory.json`",
        "Validation report with pass/fail status",
        "List of any validation errors or warnings"
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Role": {
        "docId": "role"
      }
    }
  },
  "workspace#parseworkspaceconfig": {
    "operation": {
      "ref": "workspace#parseworkspaceconfig",
      "title": "ParseWorkspaceConfig",
      "content": "Parse and extract configuration from a `.workspace` file.\n\n**Input:**\n- Path to `.workspace` file\n\n**Steps:**\n1. Read `.workspace` file contents\n2. Parse JSON structure\n3. Validate JSON schema against Workspace configuration schema\n4. Extract configuration values into structured format\n5. Apply defaults for optional fields (inputSource: \"input\", outputDestination: \"output\")\n6. Return parsed configuration object\n\n**Output:**\n- Parsed workspace configuration object\n- Any parsing errors or warnings",
      "attrs": {},
      "steps": [
        "Path to `.workspace` file",
        "Read `.workspace` file contents",
        "Parse JSON structure",
        "Validate JSON schema against Workspace configuration schema",
        "Extract configuration values into structured format",
        "Apply defaults for optional fields (inputSource: \"input\", outputDestination: \"output\")",
        "Return parsed configuration object",
        "Parsed workspace configuration object",
        "Any parsing errors or warnings"
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Role": {
        "docId": "role"
      }
    }
  },
  "workspace#detectworkspacetype": {
    "operation": {
      "ref": "workspace#detectworkspacetype",
      "title": "DetectWorkspaceType",
      "content": "Determine the type and complexity of a workspace.\n\n**Input:**\n- Workspace directory path\n\n**Steps:**\n1. Parse workspace configuration\n2. Check `hasSteps` flag\n3. Check `hasRole` flag\n4. Check `nestedWorkspaces` array\n5. Count step folders in directory\n6. Determine workspace type:\n   - **Simple**: Single operation, no steps, no nested workspaces, no role\n   - **Role-Based**: Has role context, single operation\n   - **Multi-Step**: Has sequential steps, no nested workspaces\n   - **Nested**: Has nested workspaces, no steps\n   - **Hybrid**: Has both steps and nested workspaces\n7. Return workspace type classification\n\n**Output:**\n- Workspace type classification\n- Complexity indicators (step count, nested workspace count, role presence)",
      "attrs": {},
      "steps": [
        "Workspace directory path",
        "Parse workspace configuration",
        "Check `hasSteps` flag",
        "Check `hasRole` flag",
        "Check `nestedWorkspaces` array",
        "Count step folders in directory",
        "Determine workspace type:",
        "**Simple**: Single operation, no steps, no nested workspaces, no role",
        "**Role-Based**: Has role context, single operation",
        "**Multi-Step**: Has sequential steps, no nested workspaces",
        "**Nested**: Has nested workspaces, no steps",
        "**Hybrid**: Has both steps and nested workspaces",
        "Return workspace type classification",
        "Workspace type classification",
        "Complexity indicators (step count, nested workspace count, role presence)"
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Role": {
        "docId": "role"
      }
    }
  },
  "document_optimizer#optimizedocument": {
    "operation": {
      "ref": "document_optimizer#optimizedocument",
      "title": "OptimizeDocument",
      "content": "- **Input:**\n    - `target_doc` (string): Path to the [Document] to optimize.\n    - `objective` (string|object): Natural-language goal and/or checklist-style expectations.\n    - `max_iterations` (number, optional): Iteration budget.\n    - `stop_delta` (number, optional): Minimum score improvement to keep iterating.\n    - `autonomy` (string, optional): `manual` | `assisted` | `autonomous`.\n    - `ancestor_scope` (string, optional): `self_only` | `nearest_ancestor` | `hierarchy`.\n- **Steps:**\n    1. Log entry: `timestamp | Document Optimizer -> OptimizeDocument | begin target={{target_doc}}`.\n    2. [EvaluateDocument] for `target_doc` to load its [Setup](../core/document.busy.md#setup-section) and identify its [Operations](../core/document.busy.md#operations-section).\n    3. Resolve `doc_type` from the frontmatter `Type` (e.g., `[Document]`, `[Operation]`, `[Playbook]`, `[Tool]`, `[Prompt]`, `[Role]`, `[Test]`, `[WorkspaceContext]`, `[Trace]`).\n    4. Initialize `run_id` and defaults for `max_iterations`, `stop_delta`, `autonomy`, `ancestor_scope`, `verbosity`.\n    4. Call [Trace#CreateRunDirectory](../core/trace.busy.md#createrundirectory) with `run_id`; write `run.json` manifest (target, objective, settings).\n    5. Temporarily set Workspace `Log Level` to `verbose` for this run; on completion, restore prior level.\n    7. For `iteration` in `1..max_iterations`:\n        - Call [_GenerateExamples] with `target_doc`, `doc_type`, and `objective` → `examples` (plus `holdout`). Save to `runs/<run_id>/examples/` and `holdout/` with a generator manifest describing type-specific cases.\n        - Call [_RunExamples] with `examples` → structured traces (append to [Trace] `optimizer.ndjson` after scoring) and per-example instruction traces under `runs/<run_id>/trial-traces/` and `trial-instructions/`.\n        - Call [_VerifyChecklist] to enumerate and verify `### [Checklist](../core/checklist.busy.md#checklist)` items corresponding to the invoked operation in `target_doc`; for each item, record a [ChecklistVerification] under `runs/<run_id>/checklists/` and attach a summary to the human-readable trial log.\n        - If `strict_mode` is enabled, call [_PreflightStrictChecks] to validate imports/anchors and instruction-trace presence, recording violations under `runs/<run_id>/logs/` and annotating example errors.\n        - Call [_VerifyOrderOfOperations] over all example traces to ensure strict order adherence; record any mismatches as errors and artifacts under the run directory.\n        - Call [_ScoreRun] with the collected traces and `objective` → `score` and breakdown. Write `iterations/iteration-<n>/manifest.json`.\n        - If `iteration == 1`, set `best_score = score`.\n        - Call [_ProposePatches] with `target_doc`, `ancestor_scope`, traces, and `objective` → `candidates` (diffs + rationale). Save candidates to `runs/<run_id>/candidates/iteration-<n>/`.\n        - Call [_SimulateAndSelect] with `candidates` and `holdout` → `chosen_candidate` and `chosen_score`. Save simulation traces under `runs/<run_id>/iterations/iteration-<n>/`.\n        - If `chosen_score <= best_score + stop_delta`: break (converged).\n        - Call [_ApplyOrStage] with `chosen_candidate` and `autonomy` → apply or stage patch; write patch and rollback to `runs/<run_id>/patches/`.\n        - Update `best_score = chosen_score`.\n    7. Call [Trace#SummarizeRun](../core/trace.busy.md#summarizerun) for `run_id`; write `summary.json` into the run directory.\n    8. Return a concise report with final score, iterations executed, links to the [Run Directory], and any applied patches.",
      "attrs": {},
      "steps": [
        "**Input:**",
        "`target_doc` (string): Path to the [Document] to optimize.",
        "`objective` (string|object): Natural-language goal and/or checklist-style expectations.",
        "`max_iterations` (number, optional): Iteration budget.",
        "`stop_delta` (number, optional): Minimum score improvement to keep iterating.",
        "`autonomy` (string, optional): `manual` | `assisted` | `autonomous`.",
        "`ancestor_scope` (string, optional): `self_only` | `nearest_ancestor` | `hierarchy`.",
        "**Steps:**",
        "Log entry: `timestamp | Document Optimizer -> OptimizeDocument | begin target={{target_doc}}`.",
        "[EvaluateDocument] for `target_doc` to load its [Setup](../core/document.busy.md#setup-section) and identify its [Operations](../core/document.busy.md#operations-section).",
        "Resolve `doc_type` from the frontmatter `Type` (e.g., `[Document]`, `[Operation]`, `[Playbook]`, `[Tool]`, `[Prompt]`, `[Role]`, `[Test]`, `[WorkspaceContext]`, `[Trace]`).",
        "Initialize `run_id` and defaults for `max_iterations`, `stop_delta`, `autonomy`, `ancestor_scope`, `verbosity`.",
        "Call [Trace#CreateRunDirectory](../core/trace.busy.md#createrundirectory) with `run_id`; write `run.json` manifest (target, objective, settings).",
        "Temporarily set Workspace `Log Level` to `verbose` for this run; on completion, restore prior level.",
        "For `iteration` in `1..max_iterations`:",
        "Call [_GenerateExamples] with `target_doc`, `doc_type`, and `objective` → `examples` (plus `holdout`). Save to `runs/<run_id>/examples/` and `holdout/` with a generator manifest describing type-specific cases.",
        "Call [_RunExamples] with `examples` → structured traces (append to [Trace] `optimizer.ndjson` after scoring) and per-example instruction traces under `runs/<run_id>/trial-traces/` and `trial-instructions/`.",
        "Call [_VerifyChecklist] to enumerate and verify `### [Checklist](../core/checklist.busy.md#checklist)` items corresponding to the invoked operation in `target_doc`; for each item, record a [ChecklistVerification] under `runs/<run_id>/checklists/` and attach a summary to the human-readable trial log.",
        "If `strict_mode` is enabled, call [_PreflightStrictChecks] to validate imports/anchors and instruction-trace presence, recording violations under `runs/<run_id>/logs/` and annotating example errors.",
        "Call [_VerifyOrderOfOperations] over all example traces to ensure strict order adherence; record any mismatches as errors and artifacts under the run directory.",
        "Call [_ScoreRun] with the collected traces and `objective` → `score` and breakdown. Write `iterations/iteration-<n>/manifest.json`.",
        "If `iteration == 1`, set `best_score = score`.",
        "Call [_ProposePatches] with `target_doc`, `ancestor_scope`, traces, and `objective` → `candidates` (diffs + rationale). Save candidates to `runs/<run_id>/candidates/iteration-<n>/`.",
        "Call [_SimulateAndSelect] with `candidates` and `holdout` → `chosen_candidate` and `chosen_score`. Save simulation traces under `runs/<run_id>/iterations/iteration-<n>/`.",
        "If `chosen_score <= best_score + stop_delta`: break (converged).",
        "Call [_ApplyOrStage] with `chosen_candidate` and `autonomy` → apply or stage patch; write patch and rollback to `runs/<run_id>/patches/`.",
        "Update `best_score = chosen_score`.",
        "Call [Trace#SummarizeRun](../core/trace.busy.md#summarizerun) for `run_id`; write `summary.json` into the run directory.",
        "Return a concise report with final score, iterations executed, links to the [Run Directory], and any applied patches."
      ],
      "checklist": [
        "Confirm `.trace/optimizer.ndjson` contains entries for each example executed.",
        "Confirm final report shows a non-decreasing best score across iterations.",
        "Confirm each applied patch includes a rationale citing trace evidence.",
        "Confirm [Run Directory] `.trace/runs/<run_id>/` exists with examples, trial traces, candidates, patches, iterations, and logs populated.",
        "Confirm Workspace `Log Level` was set to `verbose` during the run and restored afterward."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  },
  "document_optimizer#_generateexamples": {
    "operation": {
      "ref": "document_optimizer#_generateexamples",
      "title": "_GenerateExamples",
      "content": "- **Input:** `target_doc`, `doc_type` (optional), `objective`, `run_id`.\n- **Steps:**\n    1. Parse frontmatter to extract `Name`, `Type`, and `Description`; if `doc_type` is not provided, derive it from `Type`. If unknown, treat as a generic `[Document]` for generation purposes.\n    2. Analyze structure:\n        - Collect [Operations] via [Document#ListOperations](../core/document.busy.md#listoperations).\n        - For each operation heading, extract normative steps by reading ordered lists under the operation (e.g., “When … it should: 1., 2., 3.”).\n        - Detect `Input:` blocks either under the operation body or via a `## Input` local definition pattern; capture input names and hints.\n        - Detect `### [Checklist](../core/checklist.busy.md#checklist)` items and record their text for verification.\n        - Mine `# [Setup](../core/document.busy.md#setup-section)` and “[Local Definitions](../core/document.busy.md#local-definitions-section)” for defaults (e.g., `Trace Directory`, paths, autonomy) to seed inputs.\n    3. Synthesize inputs (heuristics):\n        - Paths: prefer workspace‑relative paths; if hints include “Trace Directory”, set to `.trace`.\n        - Enumerations: choose nominal and edge values (first/last); include an invalid value for negative cases.\n        - Free‑text: derive minimal and longer variants from `Description` keywords.\n        - Missing inputs: generate cases where one required input is omitted to trigger a clear [error].\n    4. Generate examples per operation ensuring coverage:\n        - Happy path: all inputs present; `expected_statuses` all `passed`; `expected_order` equals normative order.\n        - Missing input: omit one required input; `expected_errors` include `missing_input` at the earliest step that requires it; subsequent steps `skipped`.\n        - Policy/guard rails: craft a case that would violate a constraint (e.g., out‑of‑order attempt), expecting the spec to enforce correct behavior. Treat the violation as `negative` with `expected_statuses` reflecting the enforcement.\n        - Checklist coverage: ensure each checklist item appears in at least one example’s `checklist_items` with planned evidence sources (e.g., files written, logs appended, outputs returned).\n        - Type‑aware priors (when recognizable):\n            • `[Document]`: include `EvaluateDocument` (well‑formed, unresolved import per policy) and `ListOperations` (some ops, none).\n            • `[Operation]`: include `ExecuteOperation` (missing inputs, nested op reference) and `RunChecklist` enforcement.\n            • `[Playbook]`: include `ExecutePlaybook` (condition false skip, role context, private op) and `ListPlaybookSteps`.\n            • `[Tool]`: include `InvokeTool` (missing inputs, simulate vs. run) and `DescribeCapability`.\n            • `[Prompt]`: include `ExecutePrompt` orchestration cases.\n            • `[Role]`: include `ExecuteRole` with and without incoming task.\n            • `[Test]`: include `RunTestSuite` sandbox behavior and `RunTest` teardown.\n            • `[WorkspaceContext]`: include `InitializeWorkspace` and `SetOperatingMode`.\n            • `[Trace]`: include `RecordTraceEntry` and `SummarizeRun` round‑trip.\n        - Unknown/custom types: fall back to generic coverage over discovered operations and their steps using the heuristics above.\n    5. Reserve holdout examples that exercise different branches than the selection set (e.g., a different missing input, a different checklist item focus).\n    6. Persist artifacts:\n        - Write `examples/examples.json` (array of ExampleSpec) and `holdout/holdout.json`.\n        - Write `examples/generation.json` capturing `doc_type`, discovered operations, extracted inputs, checklists, and coverage matrix (steps × examples, checklist × examples).\n    7. Return the `examples` and `holdout` sets.",
      "attrs": {},
      "steps": [
        "**Input:** `target_doc`, `doc_type` (optional), `objective`, `run_id`.",
        "**Steps:**",
        "Parse frontmatter to extract `Name`, `Type`, and `Description`; if `doc_type` is not provided, derive it from `Type`. If unknown, treat as a generic `[Document]` for generation purposes.",
        "Analyze structure:",
        "Collect [Operations] via [Document#ListOperations](../core/document.busy.md#listoperations).",
        "For each operation heading, extract normative steps by reading ordered lists under the operation (e.g., “When … it should: 1., 2., 3.”).",
        "Detect `Input:` blocks either under the operation body or via a `## Input` local definition pattern; capture input names and hints.",
        "Detect `### [Checklist](../core/checklist.busy.md#checklist)` items and record their text for verification.",
        "Mine `# [Setup](../core/document.busy.md#setup-section)` and “[Local Definitions](../core/document.busy.md#local-definitions-section)” for defaults (e.g., `Trace Directory`, paths, autonomy) to seed inputs.",
        "Synthesize inputs (heuristics):",
        "Paths: prefer workspace‑relative paths; if hints include “Trace Directory”, set to `.trace`.",
        "Enumerations: choose nominal and edge values (first/last); include an invalid value for negative cases.",
        "Free‑text: derive minimal and longer variants from `Description` keywords.",
        "Missing inputs: generate cases where one required input is omitted to trigger a clear [error].",
        "Generate examples per operation ensuring coverage:",
        "Happy path: all inputs present; `expected_statuses` all `passed`; `expected_order` equals normative order.",
        "Missing input: omit one required input; `expected_errors` include `missing_input` at the earliest step that requires it; subsequent steps `skipped`.",
        "Policy/guard rails: craft a case that would violate a constraint (e.g., out‑of‑order attempt), expecting the spec to enforce correct behavior. Treat the violation as `negative` with `expected_statuses` reflecting the enforcement.",
        "Checklist coverage: ensure each checklist item appears in at least one example’s `checklist_items` with planned evidence sources (e.g., files written, logs appended, outputs returned).",
        "Type‑aware priors (when recognizable): • `[Document]`: include `EvaluateDocument` (well‑formed, unresolved import per policy) and `ListOperations` (some ops, none). • `[Operation]`: include `ExecuteOperation` (missing inputs, nested op reference) and `RunChecklist` enforcement. • `[Playbook]`: include `ExecutePlaybook` (condition false skip, role context, private op) and `ListPlaybookSteps`. • `[Tool]`: include `InvokeTool` (missing inputs, simulate vs. run) and `DescribeCapability`. • `[Prompt]`: include `ExecutePrompt` orchestration cases. • `[Role]`: include `ExecuteRole` with and without incoming task. • `[Test]`: include `RunTestSuite` sandbox behavior and `RunTest` teardown. • `[WorkspaceContext]`: include `InitializeWorkspace` and `SetOperatingMode`. • `[Trace]`: include `RecordTraceEntry` and `SummarizeRun` round‑trip.",
        "Unknown/custom types: fall back to generic coverage over discovered operations and their steps using the heuristics above.",
        "Reserve holdout examples that exercise different branches than the selection set (e.g., a different missing input, a different checklist item focus).",
        "Persist artifacts:",
        "Write `examples/examples.json` (array of ExampleSpec) and `holdout/holdout.json`.",
        "Write `examples/generation.json` capturing `doc_type`, discovered operations, extracted inputs, checklists, and coverage matrix (steps × examples, checklist × examples).",
        "Return the `examples` and `holdout` sets."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  },
  "document_optimizer#_runexamples": {
    "operation": {
      "ref": "document_optimizer#_runexamples",
      "title": "_RunExamples",
      "content": "- **Input:** `examples`, `run_id`, `iteration`, `target_doc`, `trace_file`.\n- **Steps:**\n    1. For each example:\n        - Execute the referenced [Operation] following [ExecuteOperation](../core/operation.busy.md#executeoperation) strictly.\n        - For each instruction/step executed, record an instruction-level trace:\n            - Append `{ index, expected, observed, status, notes }` using [Trace#RecordStepTrace](../core/trace.busy.md#recordsteptrace) to `trial-traces/example-<id>.ndjson`.\n            - Write a human-readable `trial-instructions/example-<id>.md` capturing every instruction with timing and outcomes.\n        - If the target operation defines a `### [Checklist](../core/checklist.busy.md#checklist)`, enumerate each item in order and for each:\n            - Produce evidence and a short rationale derived from observed steps or artifacts.\n            - Append a [ChecklistVerification] line using [RecordChecklistVerification] to `checklists/example-<id>.jsonl` and mirror a summary into the human-readable log.\n        - Capture run-level results, errors, and metrics; defer emitting the final [TraceEntry] until scoring so it can include `order_ok`, `score_components`, `checklist_verifications`, and computed `score`.\n        - Persist any intermediate artifacts (e.g., resolved imports, evaluated setup state) under `runs/<run_id>/logs/` via [Trace#RecordArtifact](../core/trace.busy.md#recordartifact).\n    2. Echo brief summaries to `trace.log` for readability.",
      "attrs": {},
      "steps": [
        "**Input:** `examples`, `run_id`, `iteration`, `target_doc`, `trace_file`.",
        "**Steps:**",
        "For each example:",
        "Execute the referenced [Operation] following [ExecuteOperation](../core/operation.busy.md#executeoperation) strictly.",
        "For each instruction/step executed, record an instruction-level trace:",
        "Append `{ index, expected, observed, status, notes }` using [Trace#RecordStepTrace](../core/trace.busy.md#recordsteptrace) to `trial-traces/example-<id>.ndjson`.",
        "Write a human-readable `trial-instructions/example-<id>.md` capturing every instruction with timing and outcomes.",
        "If the target operation defines a `### [Checklist](../core/checklist.busy.md#checklist)`, enumerate each item in order and for each:",
        "Produce evidence and a short rationale derived from observed steps or artifacts.",
        "Append a [ChecklistVerification] line using [RecordChecklistVerification] to `checklists/example-<id>.jsonl` and mirror a summary into the human-readable log.",
        "Capture run-level results, errors, and metrics; defer emitting the final [TraceEntry] until scoring so it can include `order_ok`, `score_components`, `checklist_verifications`, and computed `score`.",
        "Persist any intermediate artifacts (e.g., resolved imports, evaluated setup state) under `runs/<run_id>/logs/` via [Trace#RecordArtifact](../core/trace.busy.md#recordartifact).",
        "Echo brief summaries to `trace.log` for readability."
      ],
      "checklist": [
        "For every example, a `trial-traces/example-<id>.ndjson` file exists with instruction-level entries.",
        "For every example, a `trial-instructions/example-<id>.md` file exists with human-readable steps and timings.",
        "A corresponding [TraceEntry] exists in `optimizer.ndjson`."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  },
  "document_optimizer#_scorerun": {
    "operation": {
      "ref": "document_optimizer#_scorerun",
      "title": "_ScoreRun",
      "content": "- **Input:** Traces for `run_id` and `iteration`, plus `objective` and `scoring.weights`.\n- **Steps:**\n    1. For each example, derive `status_match`, `unexpected_error_rate`, and `checklist_pass_rate` from the instruction-level traces and checklist results; verify order-of-operations to compute `order_ok`.\n       - If `strict_mode` and the invoked operation has no `### [Checklist](../core/checklist.busy.md#checklist)`, set `checklist_pass_rate = 0`.\n       - If `strict_mode` and any checklist item lacks evidence, mark that item `failed` and lower `checklist_pass_rate` accordingly.\n       - If `strict_mode` and unresolved imports/anchors were detected, add an `execution_error` to errors and increase `unexpected_error_rate`.\n    2. Compute per-example scores using the default formula and weights:\n       `score_example = order_ok * (w_s*status_match + w_e*(1 - unexpected_error_rate) + w_c*checklist_pass_rate)`.\n    3. Aggregate the iteration score as the mean of per-example scores; compute pass/fail totals and error taxonomy breakdowns.\n    4. Persist results:\n        - Write `iterations/iteration-<n>/scores.json` containing per-example `score_components`, `order_ok`, `score`, and weights.\n        - Update `iterations/iteration-<n>/manifest.json` with `mean_score`, `weights`, and error breakdowns.\n    5. For each example, compose and append a final [TraceEntry] to the `trace_file` including `order_ok`, `score_components`, and `score` using [Trace#RecordTraceEntry](../core/trace.busy.md#recordtraceentry).\n    6. Return the iteration `mean_score` and a concise breakdown for reporting.",
      "attrs": {},
      "steps": [
        "**Input:** Traces for `run_id` and `iteration`, plus `objective` and `scoring.weights`.",
        "**Steps:**",
        "For each example, derive `status_match`, `unexpected_error_rate`, and `checklist_pass_rate` from the instruction-level traces and checklist results; verify order-of-operations to compute `order_ok`.",
        "If `strict_mode` and the invoked operation has no `### [Checklist](../core/checklist.busy.md#checklist)`, set `checklist_pass_rate = 0`.",
        "If `strict_mode` and any checklist item lacks evidence, mark that item `failed` and lower `checklist_pass_rate` accordingly.",
        "If `strict_mode` and unresolved imports/anchors were detected, add an `execution_error` to errors and increase `unexpected_error_rate`.",
        "Compute per-example scores using the default formula and weights: `score_example = order_ok * (w_s*status_match + w_e*(1 - unexpected_error_rate) + w_c*checklist_pass_rate)`.",
        "Aggregate the iteration score as the mean of per-example scores; compute pass/fail totals and error taxonomy breakdowns.",
        "Persist results:",
        "Write `iterations/iteration-<n>/scores.json` containing per-example `score_components`, `order_ok`, `score`, and weights.",
        "Update `iterations/iteration-<n>/manifest.json` with `mean_score`, `weights`, and error breakdowns.",
        "For each example, compose and append a final [TraceEntry] to the `trace_file` including `order_ok`, `score_components`, and `score` using [Trace#RecordTraceEntry](../core/trace.busy.md#recordtraceentry).",
        "Return the iteration `mean_score` and a concise breakdown for reporting."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  },
  "document_optimizer#_preflightstrictchecks": {
    "operation": {
      "ref": "document_optimizer#_preflightstrictchecks",
      "title": "_PreflightStrictChecks",
      "content": "- **Input:** `run_id`, `target_doc`.\n- **Steps:**\n    1. Parse reference-style imports directly below frontmatter, lines formatted as `[Alias]: path[#anchor]`.\n    2. For each import, resolve path relative to `target_doc`; if the file does not exist, record a violation.\n    3. If an anchor fragment is present, scan the target file’s headings and confirm the anchor resolves (normalize case/punctuation). Record any unresolved anchors as violations.\n    4. Confirm instruction-level trace files exist for each example; if any are missing or empty, record an order verification violation.\n    5. Write violations as JSON into `runs/<run_id>/logs/strict-violations.json` for downstream scoring.",
      "attrs": {},
      "steps": [
        "**Input:** `run_id`, `target_doc`.",
        "**Steps:**",
        "Parse reference-style imports directly below frontmatter, lines formatted as `[Alias]: path[#anchor]`.",
        "For each import, resolve path relative to `target_doc`; if the file does not exist, record a violation.",
        "If an anchor fragment is present, scan the target file’s headings and confirm the anchor resolves (normalize case/punctuation). Record any unresolved anchors as violations.",
        "Confirm instruction-level trace files exist for each example; if any are missing or empty, record an order verification violation.",
        "Write violations as JSON into `runs/<run_id>/logs/strict-violations.json` for downstream scoring."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  },
  "document_optimizer#_verifychecklist": {
    "operation": {
      "ref": "document_optimizer#_verifychecklist",
      "title": "_VerifyChecklist",
      "content": "- **Input:** `run_id`, `iteration`, `target_doc`.\n- **Steps:**\n    1. For each example, locate the invoked operation’s `### [Checklist](../core/checklist.busy.md#checklist)` in `target_doc` (if any) and ensure each item has a corresponding [ChecklistVerification] record.\n    2. If any item lacks evidence or a rationale, record a `checklist_failure` in errors and mark its verification `failed` with an explanatory note.\n    3. Summarize per-example checklist pass/fail counts for inclusion in scoring (`checklist_pass_rate`).",
      "attrs": {},
      "steps": [
        "**Input:** `run_id`, `iteration`, `target_doc`.",
        "**Steps:**",
        "For each example, locate the invoked operation’s `### [Checklist](../core/checklist.busy.md#checklist)` in `target_doc` (if any) and ensure each item has a corresponding [ChecklistVerification] record.",
        "If any item lacks evidence or a rationale, record a `checklist_failure` in errors and mark its verification `failed` with an explanatory note.",
        "Summarize per-example checklist pass/fail counts for inclusion in scoring (`checklist_pass_rate`)."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  },
  "document_optimizer#_verifyorderofoperations": {
    "operation": {
      "ref": "document_optimizer#_verifyorderofoperations",
      "title": "_VerifyOrderOfOperations",
      "content": "- **Input:** `run_id`, `iteration`, `target_doc`.\n- **Steps:**\n    1. For each example's instruction trace, reconstruct expected order based on [EvaluateDocument] (frontmatter → imports → setup → operations) and the target operation's own defined steps via [ExecuteOperation].\n    2. Compare observed order to expected; allow no reordering unless explicitly permitted by the spec.\n    3. Record any mismatches as `checklist_failure` with details under `trial-traces/` and an explanatory markdown under `trial-instructions/`.\n    4. Return a summary with counts of order matches/mismatches for inclusion in scoring.",
      "attrs": {},
      "steps": [
        "**Input:** `run_id`, `iteration`, `target_doc`.",
        "**Steps:**",
        "For each example's instruction trace, reconstruct expected order based on [EvaluateDocument] (frontmatter → imports → setup → operations) and the target operation's own defined steps via [ExecuteOperation].",
        "Compare observed order to expected; allow no reordering unless explicitly permitted by the spec.",
        "Record any mismatches as `checklist_failure` with details under `trial-traces/` and an explanatory markdown under `trial-instructions/`.",
        "Return a summary with counts of order matches/mismatches for inclusion in scoring."
      ],
      "checklist": [
        "Each example has a computed expected sequence derived from [EvaluateDocument] and [ExecuteOperation].",
        "Any mismatch is recorded as `checklist_failure` with explicit indices and step names."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  },
  "document_optimizer#_proposepatches": {
    "operation": {
      "ref": "document_optimizer#_proposepatches",
      "title": "_ProposePatches",
      "content": "- **Input:** `target_doc`, `ancestor_scope`, traces, `objective`.\n- **Steps:**\n    1. Attribute failures to likely edit sites using step text, operation names, and error patterns.\n    2. Synthesize minimal diffs with clear rationales. Patch types: clarify step wording, reorder steps, add defaults in [Setup](../core/document.busy.md#setup-section), refine [Checklist](../core/checklist.busy.md#checklist) items.\n    3. Respect `ancestor_scope`:\n        - `self_only`: only `target_doc` allowed.\n        - `nearest_ancestor`: allow directly imported documents affecting failing ops.\n        - `hierarchy`: walk import chain; cap breadth to 1–2 layers.\n    4. Save each candidate diff, rationale, and affected files list to `runs/<run_id>/candidates/iteration-<n>/`.\n    5. Return a small set of patch candidates.",
      "attrs": {},
      "steps": [
        "**Input:** `target_doc`, `ancestor_scope`, traces, `objective`.",
        "**Steps:**",
        "Attribute failures to likely edit sites using step text, operation names, and error patterns.",
        "Synthesize minimal diffs with clear rationales. Patch types: clarify step wording, reorder steps, add defaults in [Setup](../core/document.busy.md#setup-section), refine [Checklist](../core/checklist.busy.md#checklist) items.",
        "Respect `ancestor_scope`:",
        "`self_only`: only `target_doc` allowed.",
        "`nearest_ancestor`: allow directly imported documents affecting failing ops.",
        "`hierarchy`: walk import chain; cap breadth to 1–2 layers.",
        "Save each candidate diff, rationale, and affected files list to `runs/<run_id>/candidates/iteration-<n>/`.",
        "Return a small set of patch candidates."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  },
  "document_optimizer#_simulateandselect": {
    "operation": {
      "ref": "document_optimizer#_simulateandselect",
      "title": "_SimulateAndSelect",
      "content": "- **Input:** `candidates`, `holdout`, `run_id`, `iteration`.\n- **Steps:**\n    1. For each candidate, simulate the patch in-memory (without writing to disk) and run the `holdout` subset.\n    2. Score each candidate on the holdout; select the highest-scoring patch (tie-break on fewer regressions).\n    3. Persist simulation traces and scores to `runs/<run_id>/iterations/iteration-<n>/`.\n    4. Return `chosen_candidate` and its `chosen_score`.",
      "attrs": {},
      "steps": [
        "**Input:** `candidates`, `holdout`, `run_id`, `iteration`.",
        "**Steps:**",
        "For each candidate, simulate the patch in-memory (without writing to disk) and run the `holdout` subset.",
        "Score each candidate on the holdout; select the highest-scoring patch (tie-break on fewer regressions).",
        "Persist simulation traces and scores to `runs/<run_id>/iterations/iteration-<n>/`.",
        "Return `chosen_candidate` and its `chosen_score`."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  },
  "document_optimizer#_applyorstage": {
    "operation": {
      "ref": "document_optimizer#_applyorstage",
      "title": "_ApplyOrStage",
      "content": "- **Input:** `chosen_candidate`, `autonomy`.\n- **Steps:**\n    1. If `autonomy == manual`: stage the diff for approval without applying; include rationale and affected files; save to `runs/<run_id>/patches/`.\n    2. If `autonomy == assisted`: auto-apply local `target_doc` patches; stage ancestor edits for approval; write both applied and staged artifacts.\n    3. If `autonomy == autonomous`: apply patch and prepare a rollback patch if the next iteration regresses; write both to `runs/<run_id>/patches/`.",
      "attrs": {},
      "steps": [
        "**Input:** `chosen_candidate`, `autonomy`.",
        "**Steps:**",
        "If `autonomy == manual`: stage the diff for approval without applying; include rationale and affected files; save to `runs/<run_id>/patches/`.",
        "If `autonomy == assisted`: auto-apply local `target_doc` patches; stage ancestor edits for approval; write both applied and staged artifacts.",
        "If `autonomy == autonomous`: apply patch and prepare a rollback patch if the next iteration regresses; write both to `runs/<run_id>/patches/`."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  },
  "document_optimizer#_convergencecheck": {
    "operation": {
      "ref": "document_optimizer#_convergencecheck",
      "title": "_ConvergenceCheck",
      "content": "- **Input:** `best_score`, `chosen_score`, `stop_delta`, `iteration`, `max_iterations`.\n- **Steps:**\n    1. If `iteration >= max_iterations`: stop.\n    2. If `chosen_score <= best_score + stop_delta`: stop (no meaningful improvement).\n    3. Otherwise continue.",
      "attrs": {},
      "steps": [
        "**Input:** `best_score`, `chosen_score`, `stop_delta`, `iteration`, `max_iterations`.",
        "**Steps:**",
        "If `iteration >= max_iterations`: stop.",
        "If `chosen_score <= best_score + stop_delta`: stop (no meaningful improvement).",
        "Otherwise continue."
      ],
      "checklist": [
        "Ensure stop criteria triggered only when score improvement is below `stop_delta` or the iteration budget is exhausted.",
        "Ensure any staged or applied patches include minimal diffs and rationale."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  },
  "busy_assistant#executerole": {
    "operation": {
      "ref": "busy_assistant#executerole",
      "title": "ExecuteRole",
      "content": "This is the primary [Operation] for a [Role] [Document]. It determines the [Role]'s behavior based on the execution context.\n\n1.  **Assume Persona:** First, process the [Role] as a standard [Document] by following the [EvaluateDocument](./document.busy.md#evaluatedocument) [Operation]. This includes executing the `# [Setup](./document.busy.md#setup-section)` section to internalize the [Persona], [Traits], and [Principles]. Log the assumption of the [Role].\n2.  **Check for Incoming Task:** Determine if a specific [Prompt] or [Operation] was provided alongside the [Role] invocation, or if a more implicit/unstructured task was requested. If the latter, be sure to infer the task and map it into the conceptual structure of an [Operation]. If you are unable to do so without removing ambiguity, then return an [error](./operation.busy.md#error).\n3.  **Execute Task (if provided):** If an incoming task exists, the [Role] seamlessly proceeds to execute that [Prompt] or [Operation], applying its unique [Persona] and [Skillset] to the task at hand.\n4.  **Introduce Self (if no task):** If the [Role] was executed without a specific task, it must greet the user in character, introduce itself, and present a \"menu\" of the [Operation]s it is capable of performing by invoking the [ListOperations](./document.busy.md#listoperations) [Operation].",
      "attrs": {},
      "steps": [
        "**Assume Persona:** First, process the [Role] as a standard [Document] by following the [EvaluateDocument](./document.busy.md#evaluatedocument) [Operation]. This includes executing the `# [Setup](./document.busy.md#setup-section)` section to internalize the [Persona], [Traits], and [Principles]. Log the assumption of the [Role].",
        "**Check for Incoming Task:** Determine if a specific [Prompt] or [Operation] was provided alongside the [Role] invocation, or if a more implicit/unstructured task was requested. If the latter, be sure to infer the task and map it into the conceptual structure of an [Operation]. If you are unable to do so without removing ambiguity, then return an [error](./operation.busy.md#error).",
        "**Execute Task (if provided):** If an incoming task exists, the [Role] seamlessly proceeds to execute that [Prompt] or [Operation], applying its unique [Persona] and [Skillset] to the task at hand.",
        "**Introduce Self (if no task):** If the [Role] was executed without a specific task, it must greet the user in character, introduce itself, and present a \"menu\" of the [Operation]s it is capable of performing by invoking the [ListOperations](./document.busy.md#listoperations) [Operation]."
      ],
      "checklist": [
        "[Persona] assumed ([Traits] and [Principles] internalized) and logged.",
        "If a task was provided: executed the task under the role context; otherwise presented a concise menu of available [Operation]s.",
        "Any state or outputs produced are clearly attributed to this [Role]."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "Tool": {
        "docId": "tool"
      },
      "Playbook": {
        "docId": "playbook"
      }
    }
  },
  "busy_formatting_rules#runchecklist": {
    "operation": {
      "ref": "busy_formatting_rules#runchecklist",
      "title": "RunChecklist",
      "content": "When a callable defines a [Checklist], the agent must:\n1. **Locate the Checklist:** After completing the main steps, identify the `Checklist` section and enumerate every [Checklist Item].\n2. **Verify Sequentially:** Address each item in order, gathering evidence or logs that demonstrate the outcome is satisfied. If an item cannot be verified, stop and return an [error] describing the gap.\n3. **Record Evidence:** Note how each verification was satisfied (e.g., test output, file diff, user confirmation) so downstream consumers understand the proof of completion.\n4. **Confirm Completion:** Once all items are verified, explicitly state that the [Checklist] has been completed and summarize any findings uncovered during verification.",
      "attrs": {},
      "steps": [
        "**Locate the Checklist:** After completing the main steps, identify the `Checklist` section and enumerate every [Checklist Item].",
        "**Verify Sequentially:** Address each item in order, gathering evidence or logs that demonstrate the outcome is satisfied. If an item cannot be verified, stop and return an [error] describing the gap.",
        "**Record Evidence:** Note how each verification was satisfied (e.g., test output, file diff, user confirmation) so downstream consumers understand the proof of completion.",
        "**Confirm Completion:** Once all items are verified, explicitly state that the [Checklist] has been completed and summarize any findings uncovered during verification."
      ],
      "checklist": [
        "All checklist items enumerated and verified in order.",
        "Evidence recorded for each item or an [error] returned specifying the missing verification.",
        "Final confirmation of checklist completion logged or reported to the caller."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Document": {
        "docId": "document"
      },
      "Concept": {
        "docId": "concept"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "EvaluateDocument": {
        "docId": "document",
        "slug": "evaluatedocument"
      },
      "RunChecklist": {
        "docId": "checklist",
        "slug": "runchecklist"
      }
    }
  },
  "workspace_agent#executerole": {
    "operation": {
      "ref": "workspace_agent#executerole",
      "title": "ExecuteRole",
      "content": "This is the primary [Operation] for a [Role] [Document]. It determines the [Role]'s behavior based on the execution context.\n\n1.  **Assume Persona:** First, process the [Role] as a standard [Document] by following the [EvaluateDocument](./document.busy.md#evaluatedocument) [Operation]. This includes executing the `# [Setup](./document.busy.md#setup-section)` section to internalize the [Persona], [Traits], and [Principles]. Log the assumption of the [Role].\n2.  **Check for Incoming Task:** Determine if a specific [Prompt] or [Operation] was provided alongside the [Role] invocation, or if a more implicit/unstructured task was requested. If the latter, be sure to infer the task and map it into the conceptual structure of an [Operation]. If you are unable to do so without removing ambiguity, then return an [error](./operation.busy.md#error).\n3.  **Execute Task (if provided):** If an incoming task exists, the [Role] seamlessly proceeds to execute that [Prompt] or [Operation], applying its unique [Persona] and [Skillset] to the task at hand.\n4.  **Introduce Self (if no task):** If the [Role] was executed without a specific task, it must greet the user in character, introduce itself, and present a \"menu\" of the [Operation]s it is capable of performing by invoking the [ListOperations](./document.busy.md#listoperations) [Operation].",
      "attrs": {},
      "steps": [
        "**Assume Persona:** First, process the [Role] as a standard [Document] by following the [EvaluateDocument](./document.busy.md#evaluatedocument) [Operation]. This includes executing the `# [Setup](./document.busy.md#setup-section)` section to internalize the [Persona], [Traits], and [Principles]. Log the assumption of the [Role].",
        "**Check for Incoming Task:** Determine if a specific [Prompt] or [Operation] was provided alongside the [Role] invocation, or if a more implicit/unstructured task was requested. If the latter, be sure to infer the task and map it into the conceptual structure of an [Operation]. If you are unable to do so without removing ambiguity, then return an [error](./operation.busy.md#error).",
        "**Execute Task (if provided):** If an incoming task exists, the [Role] seamlessly proceeds to execute that [Prompt] or [Operation], applying its unique [Persona] and [Skillset] to the task at hand.",
        "**Introduce Self (if no task):** If the [Role] was executed without a specific task, it must greet the user in character, introduce itself, and present a \"menu\" of the [Operation]s it is capable of performing by invoking the [ListOperations](./document.busy.md#listoperations) [Operation]."
      ],
      "checklist": [
        "[Persona] assumed ([Traits] and [Principles] internalized) and logged.",
        "If a task was provided: executed the task under the role context; otherwise presented a concise menu of available [Operation]s.",
        "Any state or outputs produced are clearly attributed to this [Role]."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Playbook": {
        "docId": "playbook"
      }
    }
  },
  "workspace_architect#executerole": {
    "operation": {
      "ref": "workspace_architect#executerole",
      "title": "ExecuteRole",
      "content": "This is the primary [Operation] for a [Role] [Document]. It determines the [Role]'s behavior based on the execution context.\n\n1.  **Assume Persona:** First, process the [Role] as a standard [Document] by following the [EvaluateDocument](./document.busy.md#evaluatedocument) [Operation]. This includes executing the `# [Setup](./document.busy.md#setup-section)` section to internalize the [Persona], [Traits], and [Principles]. Log the assumption of the [Role].\n2.  **Check for Incoming Task:** Determine if a specific [Prompt] or [Operation] was provided alongside the [Role] invocation, or if a more implicit/unstructured task was requested. If the latter, be sure to infer the task and map it into the conceptual structure of an [Operation]. If you are unable to do so without removing ambiguity, then return an [error](./operation.busy.md#error).\n3.  **Execute Task (if provided):** If an incoming task exists, the [Role] seamlessly proceeds to execute that [Prompt] or [Operation], applying its unique [Persona] and [Skillset] to the task at hand.\n4.  **Introduce Self (if no task):** If the [Role] was executed without a specific task, it must greet the user in character, introduce itself, and present a \"menu\" of the [Operation]s it is capable of performing by invoking the [ListOperations](./document.busy.md#listoperations) [Operation].",
      "attrs": {},
      "steps": [
        "**Assume Persona:** First, process the [Role] as a standard [Document] by following the [EvaluateDocument](./document.busy.md#evaluatedocument) [Operation]. This includes executing the `# [Setup](./document.busy.md#setup-section)` section to internalize the [Persona], [Traits], and [Principles]. Log the assumption of the [Role].",
        "**Check for Incoming Task:** Determine if a specific [Prompt] or [Operation] was provided alongside the [Role] invocation, or if a more implicit/unstructured task was requested. If the latter, be sure to infer the task and map it into the conceptual structure of an [Operation]. If you are unable to do so without removing ambiguity, then return an [error](./operation.busy.md#error).",
        "**Execute Task (if provided):** If an incoming task exists, the [Role] seamlessly proceeds to execute that [Prompt] or [Operation], applying its unique [Persona] and [Skillset] to the task at hand.",
        "**Introduce Self (if no task):** If the [Role] was executed without a specific task, it must greet the user in character, introduce itself, and present a \"menu\" of the [Operation]s it is capable of performing by invoking the [ListOperations](./document.busy.md#listoperations) [Operation]."
      ],
      "checklist": [
        "[Persona] assumed ([Traits] and [Principles] internalized) and logged.",
        "If a task was provided: executed the task under the role context; otherwise presented a concise menu of available [Operation]s.",
        "Any state or outputs produced are clearly attributed to this [Role]."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Role": {
        "docId": "role"
      },
      "Workspace": {
        "docId": "workspace"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Operation": {
        "docId": "operation"
      },
      "Document": {
        "docId": "document"
      },
      "BasicWorkspacePlaybook": {
        "docId": "build_basic_workspace_playbook"
      }
    }
  },
  "checklist#evaluatedocument": {
    "operation": {
      "ref": "checklist#evaluatedocument",
      "title": "EvaluateDocument",
      "content": "When an LLM processes a [Document], it should:\n1.  **Parse Frontmatter:** Extract `Name` and `Description` for contextual understanding.\n2.  **Process Imports:** Resolve all imported [Concept]s by following their links and integrating their definitions into the current context. If any import cannot be resolved (invalid path or anchor), immediately return an [error] describing the missing import and stop further processing; do not execute [Setup](./document.busy.md#setup-section) or later steps.\n3.  **Execute Setup:** Follow the instructions in the `# [Setup](./document.busy.md#setup-section)` section, establishing any required context, persona, or initial state. Persist any specified state to memory files.\n4.  **Enforce Strict Execution:** All defined [Operation]s MUST be executed precisely as their steps dictate, including any [Checklist] sections they define.\n5.  **Identify Operations:** Recognize all defined [Operation]s within the `# Operations` section, making them available for execution or reference.\n6.  **Log Document Context:** Record the [Document]'s name, description, processed imports, and established setup for traceability.",
      "attrs": {},
      "steps": [
        "**Parse Frontmatter:** Extract `Name` and `Description` for contextual understanding.",
        "**Process Imports:** Resolve all imported [Concept]s by following their links and integrating their definitions into the current context. If any import cannot be resolved (invalid path or anchor), immediately return an [error] describing the missing import and stop further processing; do not execute [Setup](./document.busy.md#setup-section) or later steps.",
        "**Execute Setup:** Follow the instructions in the `# [Setup](./document.busy.md#setup-section)` section, establishing any required context, persona, or initial state. Persist any specified state to memory files.",
        "**Enforce Strict Execution:** All defined [Operation]s MUST be executed precisely as their steps dictate, including any [Checklist] sections they define.",
        "**Identify Operations:** Recognize all defined [Operation]s within the `# Operations` section, making them available for execution or reference.",
        "**Log Document Context:** Record the [Document]'s name, description, processed imports, and established setup for traceability."
      ],
      "checklist": [
        "Frontmatter parsed and `Name`/`Description` captured.",
        "Imports resolved and integrated into context; unresolved imports produce a clear [error] and halt execution prior to Setup.",
        "Setup executed; any state persisted as specified.",
        "All Operations identified and made available.",
        "Document context logged (including resolved imports and setup notes)."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Checklist": {
        "docId": "checklist",
        "slug": "checklist-section"
      },
      "Checklist Item": {
        "docId": "checklist",
        "slug": "checklist-item"
      },
      "error": {
        "docId": "operation",
        "slug": "error"
      }
    }
  },
  "checklist#listoperations": {
    "operation": {
      "ref": "checklist#listoperations",
      "title": "ListOperations",
      "content": "Parses the [Document] to find all defined [Operation]s under the `# Operations` section.",
      "attrs": {},
      "steps": [
        "Parse the document.",
        "Identify all `## Headings` under `# Operations`.",
        "Present the results to the user."
      ],
      "checklist": [
        "The output MUST be presented as a numbered list.",
        "Each number MUST correspond to an operation.",
        "The user MUST be able to invoke an operation by its number.",
        "Returns only operations defined under `# Operations`.",
        "Output formatted as a numbered list.",
        "Each item clearly maps to an invocable operation."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Checklist": {
        "docId": "checklist",
        "slug": "checklist-section"
      },
      "Checklist Item": {
        "docId": "checklist",
        "slug": "checklist-item"
      },
      "error": {
        "docId": "operation",
        "slug": "error"
      }
    }
  },
  "document#evaluateconcept": {
    "operation": {
      "ref": "document#evaluateconcept",
      "title": "EvaluateConcept",
      "content": "When an LLM encounters a [Concept], it should:\n1.  **Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`).\n    *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*\n2.  **Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].\n3.  **Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.\n4.  **Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced.",
      "attrs": {},
      "steps": [
        "**Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`). *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*",
        "**Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].",
        "**Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.",
        "**Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "Tool": {
        "docId": "tool"
      },
      "Playbook": {
        "docId": "playbook"
      }
    }
  },
  "operation#evaluateconcept": {
    "operation": {
      "ref": "operation#evaluateconcept",
      "title": "EvaluateConcept",
      "content": "When an LLM encounters a [Concept], it should:\n1.  **Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`).\n    *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*\n2.  **Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].\n3.  **Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.\n4.  **Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced.",
      "attrs": {},
      "steps": [
        "**Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`). *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*",
        "**Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].",
        "**Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.",
        "**Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "RunChecklist": {
        "docId": "checklist",
        "slug": "runchecklist"
      },
      "input": {
        "docId": "operation",
        "slug": "input"
      },
      "output": {
        "docId": "operation",
        "slug": "output"
      },
      "error": {
        "docId": "operation",
        "slug": "error"
      }
    }
  },
  "playbook#evaluatedocument": {
    "operation": {
      "ref": "playbook#evaluatedocument",
      "title": "EvaluateDocument",
      "content": "When an LLM processes a [Document], it should:\n1.  **Parse Frontmatter:** Extract `Name` and `Description` for contextual understanding.\n2.  **Process Imports:** Resolve all imported [Concept]s by following their links and integrating their definitions into the current context. If any import cannot be resolved (invalid path or anchor), immediately return an [error] describing the missing import and stop further processing; do not execute [Setup](./document.busy.md#setup-section) or later steps.\n3.  **Execute Setup:** Follow the instructions in the `# [Setup](./document.busy.md#setup-section)` section, establishing any required context, persona, or initial state. Persist any specified state to memory files.\n4.  **Enforce Strict Execution:** All defined [Operation]s MUST be executed precisely as their steps dictate, including any [Checklist] sections they define.\n5.  **Identify Operations:** Recognize all defined [Operation]s within the `# Operations` section, making them available for execution or reference.\n6.  **Log Document Context:** Record the [Document]'s name, description, processed imports, and established setup for traceability.",
      "attrs": {},
      "steps": [
        "**Parse Frontmatter:** Extract `Name` and `Description` for contextual understanding.",
        "**Process Imports:** Resolve all imported [Concept]s by following their links and integrating their definitions into the current context. If any import cannot be resolved (invalid path or anchor), immediately return an [error] describing the missing import and stop further processing; do not execute [Setup](./document.busy.md#setup-section) or later steps.",
        "**Execute Setup:** Follow the instructions in the `# [Setup](./document.busy.md#setup-section)` section, establishing any required context, persona, or initial state. Persist any specified state to memory files.",
        "**Enforce Strict Execution:** All defined [Operation]s MUST be executed precisely as their steps dictate, including any [Checklist] sections they define.",
        "**Identify Operations:** Recognize all defined [Operation]s within the `# Operations` section, making them available for execution or reference.",
        "**Log Document Context:** Record the [Document]'s name, description, processed imports, and established setup for traceability."
      ],
      "checklist": [
        "Frontmatter parsed and `Name`/`Description` captured.",
        "Imports resolved and integrated into context; unresolved imports produce a clear [error] and halt execution prior to Setup.",
        "Setup executed; any state persisted as specified.",
        "All Operations identified and made available.",
        "Document context logged (including resolved imports and setup notes)."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "Role": {
        "docId": "role"
      },
      "Tool": {
        "docId": "tool"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "RunChecklist": {
        "docId": "checklist",
        "slug": "runchecklist"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Sequence Step": {
        "docId": "playbook",
        "slug": "sequence-step"
      },
      "Condition": {
        "docId": "playbook",
        "slug": "condition"
      },
      "Role Context": {
        "docId": "playbook",
        "slug": "role-context"
      },
      "Private Operation": {
        "docId": "playbook",
        "slug": "private-operation"
      },
      "ExecutePlaybook": {
        "docId": "playbook",
        "slug": "executeplaybook"
      },
      "ListPlaybookSteps": {
        "docId": "playbook",
        "slug": "listplaybooksteps"
      }
    }
  },
  "playbook#listoperations": {
    "operation": {
      "ref": "playbook#listoperations",
      "title": "ListOperations",
      "content": "Parses the [Document] to find all defined [Operation]s under the `# Operations` section.",
      "attrs": {},
      "steps": [
        "Parse the document.",
        "Identify all `## Headings` under `# Operations`.",
        "Present the results to the user."
      ],
      "checklist": [
        "The output MUST be presented as a numbered list.",
        "Each number MUST correspond to an operation.",
        "The user MUST be able to invoke an operation by its number.",
        "Returns only operations defined under `# Operations`.",
        "Output formatted as a numbered list.",
        "Each item clearly maps to an invocable operation."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "Role": {
        "docId": "role"
      },
      "Tool": {
        "docId": "tool"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "RunChecklist": {
        "docId": "checklist",
        "slug": "runchecklist"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Sequence Step": {
        "docId": "playbook",
        "slug": "sequence-step"
      },
      "Condition": {
        "docId": "playbook",
        "slug": "condition"
      },
      "Role Context": {
        "docId": "playbook",
        "slug": "role-context"
      },
      "Private Operation": {
        "docId": "playbook",
        "slug": "private-operation"
      },
      "ExecutePlaybook": {
        "docId": "playbook",
        "slug": "executeplaybook"
      },
      "ListPlaybookSteps": {
        "docId": "playbook",
        "slug": "listplaybooksteps"
      }
    }
  },
  "playbook#evaluateconcept": {
    "operation": {
      "ref": "playbook#evaluateconcept",
      "title": "EvaluateConcept",
      "content": "When an LLM encounters a [Concept], it should:\n1.  **Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`).\n    *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*\n2.  **Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].\n3.  **Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.\n4.  **Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced.",
      "attrs": {},
      "steps": [
        "**Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`). *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*",
        "**Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].",
        "**Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.",
        "**Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "Role": {
        "docId": "role"
      },
      "Tool": {
        "docId": "tool"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "RunChecklist": {
        "docId": "checklist",
        "slug": "runchecklist"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Sequence Step": {
        "docId": "playbook",
        "slug": "sequence-step"
      },
      "Condition": {
        "docId": "playbook",
        "slug": "condition"
      },
      "Role Context": {
        "docId": "playbook",
        "slug": "role-context"
      },
      "Private Operation": {
        "docId": "playbook",
        "slug": "private-operation"
      },
      "ExecutePlaybook": {
        "docId": "playbook",
        "slug": "executeplaybook"
      },
      "ListPlaybookSteps": {
        "docId": "playbook",
        "slug": "listplaybooksteps"
      }
    }
  },
  "prompt#evaluatedocument": {
    "operation": {
      "ref": "prompt#evaluatedocument",
      "title": "EvaluateDocument",
      "content": "When an LLM processes a [Document], it should:\n1.  **Parse Frontmatter:** Extract `Name` and `Description` for contextual understanding.\n2.  **Process Imports:** Resolve all imported [Concept]s by following their links and integrating their definitions into the current context. If any import cannot be resolved (invalid path or anchor), immediately return an [error] describing the missing import and stop further processing; do not execute [Setup](./document.busy.md#setup-section) or later steps.\n3.  **Execute Setup:** Follow the instructions in the `# [Setup](./document.busy.md#setup-section)` section, establishing any required context, persona, or initial state. Persist any specified state to memory files.\n4.  **Enforce Strict Execution:** All defined [Operation]s MUST be executed precisely as their steps dictate, including any [Checklist] sections they define.\n5.  **Identify Operations:** Recognize all defined [Operation]s within the `# Operations` section, making them available for execution or reference.\n6.  **Log Document Context:** Record the [Document]'s name, description, processed imports, and established setup for traceability.",
      "attrs": {},
      "steps": [
        "**Parse Frontmatter:** Extract `Name` and `Description` for contextual understanding.",
        "**Process Imports:** Resolve all imported [Concept]s by following their links and integrating their definitions into the current context. If any import cannot be resolved (invalid path or anchor), immediately return an [error] describing the missing import and stop further processing; do not execute [Setup](./document.busy.md#setup-section) or later steps.",
        "**Execute Setup:** Follow the instructions in the `# [Setup](./document.busy.md#setup-section)` section, establishing any required context, persona, or initial state. Persist any specified state to memory files.",
        "**Enforce Strict Execution:** All defined [Operation]s MUST be executed precisely as their steps dictate, including any [Checklist] sections they define.",
        "**Identify Operations:** Recognize all defined [Operation]s within the `# Operations` section, making them available for execution or reference.",
        "**Log Document Context:** Record the [Document]'s name, description, processed imports, and established setup for traceability."
      ],
      "checklist": [
        "Frontmatter parsed and `Name`/`Description` captured.",
        "Imports resolved and integrated into context; unresolved imports produce a clear [error] and halt execution prior to Setup.",
        "Setup executed; any state persisted as specified.",
        "All Operations identified and made available.",
        "Document context logged (including resolved imports and setup notes)."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Document": {
        "docId": "document"
      },
      "Concept": {
        "docId": "concept"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "prompt text": {
        "docId": "prompt",
        "slug": "prompt-text"
      },
      "Operations": {
        "docId": "document",
        "slug": "operations-section"
      }
    }
  },
  "prompt#listoperations": {
    "operation": {
      "ref": "prompt#listoperations",
      "title": "ListOperations",
      "content": "Parses the [Document] to find all defined [Operation]s under the `# Operations` section.",
      "attrs": {},
      "steps": [
        "Parse the document.",
        "Identify all `## Headings` under `# Operations`.",
        "Present the results to the user."
      ],
      "checklist": [
        "The output MUST be presented as a numbered list.",
        "Each number MUST correspond to an operation.",
        "The user MUST be able to invoke an operation by its number.",
        "Returns only operations defined under `# Operations`.",
        "Output formatted as a numbered list.",
        "Each item clearly maps to an invocable operation."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Document": {
        "docId": "document"
      },
      "Concept": {
        "docId": "concept"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "prompt text": {
        "docId": "prompt",
        "slug": "prompt-text"
      },
      "Operations": {
        "docId": "document",
        "slug": "operations-section"
      }
    }
  },
  "prompt#evaluateconcept": {
    "operation": {
      "ref": "prompt#evaluateconcept",
      "title": "EvaluateConcept",
      "content": "When an LLM encounters a [Concept], it should:\n1.  **Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`).\n    *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*\n2.  **Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].\n3.  **Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.\n4.  **Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced.",
      "attrs": {},
      "steps": [
        "**Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`). *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*",
        "**Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].",
        "**Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.",
        "**Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Document": {
        "docId": "document"
      },
      "Concept": {
        "docId": "concept"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "prompt text": {
        "docId": "prompt",
        "slug": "prompt-text"
      },
      "Operations": {
        "docId": "document",
        "slug": "operations-section"
      }
    }
  },
  "role#evaluatedocument": {
    "operation": {
      "ref": "role#evaluatedocument",
      "title": "EvaluateDocument",
      "content": "When an LLM processes a [Document], it should:\n1.  **Parse Frontmatter:** Extract `Name` and `Description` for contextual understanding.\n2.  **Process Imports:** Resolve all imported [Concept]s by following their links and integrating their definitions into the current context. If any import cannot be resolved (invalid path or anchor), immediately return an [error] describing the missing import and stop further processing; do not execute [Setup](./document.busy.md#setup-section) or later steps.\n3.  **Execute Setup:** Follow the instructions in the `# [Setup](./document.busy.md#setup-section)` section, establishing any required context, persona, or initial state. Persist any specified state to memory files.\n4.  **Enforce Strict Execution:** All defined [Operation]s MUST be executed precisely as their steps dictate, including any [Checklist] sections they define.\n5.  **Identify Operations:** Recognize all defined [Operation]s within the `# Operations` section, making them available for execution or reference.\n6.  **Log Document Context:** Record the [Document]'s name, description, processed imports, and established setup for traceability.",
      "attrs": {},
      "steps": [
        "**Parse Frontmatter:** Extract `Name` and `Description` for contextual understanding.",
        "**Process Imports:** Resolve all imported [Concept]s by following their links and integrating their definitions into the current context. If any import cannot be resolved (invalid path or anchor), immediately return an [error] describing the missing import and stop further processing; do not execute [Setup](./document.busy.md#setup-section) or later steps.",
        "**Execute Setup:** Follow the instructions in the `# [Setup](./document.busy.md#setup-section)` section, establishing any required context, persona, or initial state. Persist any specified state to memory files.",
        "**Enforce Strict Execution:** All defined [Operation]s MUST be executed precisely as their steps dictate, including any [Checklist] sections they define.",
        "**Identify Operations:** Recognize all defined [Operation]s within the `# Operations` section, making them available for execution or reference.",
        "**Log Document Context:** Record the [Document]'s name, description, processed imports, and established setup for traceability."
      ],
      "checklist": [
        "Frontmatter parsed and `Name`/`Description` captured.",
        "Imports resolved and integrated into context; unresolved imports produce a clear [error] and halt execution prior to Setup.",
        "Setup executed; any state persisted as specified.",
        "All Operations identified and made available.",
        "Document context logged (including resolved imports and setup notes)."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "Role": {
        "docId": "role"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "Persona": {
        "docId": "role",
        "slug": "persona"
      },
      "Traits": {
        "docId": "role",
        "slug": "traits"
      },
      "Principles": {
        "docId": "role",
        "slug": "principles"
      },
      "Skillset": {
        "docId": "role",
        "slug": "skillset"
      }
    }
  },
  "role#listoperations": {
    "operation": {
      "ref": "role#listoperations",
      "title": "ListOperations",
      "content": "Parses the [Document] to find all defined [Operation]s under the `# Operations` section.",
      "attrs": {},
      "steps": [
        "Parse the document.",
        "Identify all `## Headings` under `# Operations`.",
        "Present the results to the user."
      ],
      "checklist": [
        "The output MUST be presented as a numbered list.",
        "Each number MUST correspond to an operation.",
        "The user MUST be able to invoke an operation by its number.",
        "Returns only operations defined under `# Operations`.",
        "Output formatted as a numbered list.",
        "Each item clearly maps to an invocable operation."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "Role": {
        "docId": "role"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "Persona": {
        "docId": "role",
        "slug": "persona"
      },
      "Traits": {
        "docId": "role",
        "slug": "traits"
      },
      "Principles": {
        "docId": "role",
        "slug": "principles"
      },
      "Skillset": {
        "docId": "role",
        "slug": "skillset"
      }
    }
  },
  "role#evaluateconcept": {
    "operation": {
      "ref": "role#evaluateconcept",
      "title": "EvaluateConcept",
      "content": "When an LLM encounters a [Concept], it should:\n1.  **Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`).\n    *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*\n2.  **Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].\n3.  **Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.\n4.  **Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced.",
      "attrs": {},
      "steps": [
        "**Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`). *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*",
        "**Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].",
        "**Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.",
        "**Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Prompt": {
        "docId": "prompt"
      },
      "Role": {
        "docId": "role"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "Persona": {
        "docId": "role",
        "slug": "persona"
      },
      "Traits": {
        "docId": "role",
        "slug": "traits"
      },
      "Principles": {
        "docId": "role",
        "slug": "principles"
      },
      "Skillset": {
        "docId": "role",
        "slug": "skillset"
      }
    }
  },
  "tool#evaluatedocument": {
    "operation": {
      "ref": "tool#evaluatedocument",
      "title": "EvaluateDocument",
      "content": "When an LLM processes a [Document], it should:\n1.  **Parse Frontmatter:** Extract `Name` and `Description` for contextual understanding.\n2.  **Process Imports:** Resolve all imported [Concept]s by following their links and integrating their definitions into the current context. If any import cannot be resolved (invalid path or anchor), immediately return an [error] describing the missing import and stop further processing; do not execute [Setup](./document.busy.md#setup-section) or later steps.\n3.  **Execute Setup:** Follow the instructions in the `# [Setup](./document.busy.md#setup-section)` section, establishing any required context, persona, or initial state. Persist any specified state to memory files.\n4.  **Enforce Strict Execution:** All defined [Operation]s MUST be executed precisely as their steps dictate, including any [Checklist] sections they define.\n5.  **Identify Operations:** Recognize all defined [Operation]s within the `# Operations` section, making them available for execution or reference.\n6.  **Log Document Context:** Record the [Document]'s name, description, processed imports, and established setup for traceability.",
      "attrs": {},
      "steps": [
        "**Parse Frontmatter:** Extract `Name` and `Description` for contextual understanding.",
        "**Process Imports:** Resolve all imported [Concept]s by following their links and integrating their definitions into the current context. If any import cannot be resolved (invalid path or anchor), immediately return an [error] describing the missing import and stop further processing; do not execute [Setup](./document.busy.md#setup-section) or later steps.",
        "**Execute Setup:** Follow the instructions in the `# [Setup](./document.busy.md#setup-section)` section, establishing any required context, persona, or initial state. Persist any specified state to memory files.",
        "**Enforce Strict Execution:** All defined [Operation]s MUST be executed precisely as their steps dictate, including any [Checklist] sections they define.",
        "**Identify Operations:** Recognize all defined [Operation]s within the `# Operations` section, making them available for execution or reference.",
        "**Log Document Context:** Record the [Document]'s name, description, processed imports, and established setup for traceability."
      ],
      "checklist": [
        "Frontmatter parsed and `Name`/`Description` captured.",
        "Imports resolved and integrated into context; unresolved imports produce a clear [error] and halt execution prior to Setup.",
        "Setup executed; any state persisted as specified.",
        "All Operations identified and made available.",
        "Document context logged (including resolved imports and setup notes)."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Tool": {
        "docId": "tool"
      },
      "Capability": {
        "docId": "tool",
        "slug": "capability"
      },
      "Invocation Contract": {
        "docId": "tool",
        "slug": "invocation-contract"
      },
      "Inputs": {
        "docId": "tool",
        "slug": "inputs"
      },
      "Outputs": {
        "docId": "tool",
        "slug": "outputs"
      },
      "State": {
        "docId": "tool",
        "slug": "state"
      },
      "InvokeTool": {
        "docId": "tool",
        "slug": "invoketool"
      },
      "DescribeCapability": {
        "docId": "tool",
        "slug": "describecapability"
      },
      "Checklist": {
        "docId": "checklist"
      }
    }
  },
  "tool#listoperations": {
    "operation": {
      "ref": "tool#listoperations",
      "title": "ListOperations",
      "content": "Parses the [Document] to find all defined [Operation]s under the `# Operations` section.",
      "attrs": {},
      "steps": [
        "Parse the document.",
        "Identify all `## Headings` under `# Operations`.",
        "Present the results to the user."
      ],
      "checklist": [
        "The output MUST be presented as a numbered list.",
        "Each number MUST correspond to an operation.",
        "The user MUST be able to invoke an operation by its number.",
        "Returns only operations defined under `# Operations`.",
        "Output formatted as a numbered list.",
        "Each item clearly maps to an invocable operation."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Tool": {
        "docId": "tool"
      },
      "Capability": {
        "docId": "tool",
        "slug": "capability"
      },
      "Invocation Contract": {
        "docId": "tool",
        "slug": "invocation-contract"
      },
      "Inputs": {
        "docId": "tool",
        "slug": "inputs"
      },
      "Outputs": {
        "docId": "tool",
        "slug": "outputs"
      },
      "State": {
        "docId": "tool",
        "slug": "state"
      },
      "InvokeTool": {
        "docId": "tool",
        "slug": "invoketool"
      },
      "DescribeCapability": {
        "docId": "tool",
        "slug": "describecapability"
      },
      "Checklist": {
        "docId": "checklist"
      }
    }
  },
  "tool#evaluateconcept": {
    "operation": {
      "ref": "tool#evaluateconcept",
      "title": "EvaluateConcept",
      "content": "When an LLM encounters a [Concept], it should:\n1.  **Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`).\n    *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*\n2.  **Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].\n3.  **Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.\n4.  **Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced.",
      "attrs": {},
      "steps": [
        "**Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`). *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*",
        "**Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].",
        "**Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.",
        "**Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Tool": {
        "docId": "tool"
      },
      "Capability": {
        "docId": "tool",
        "slug": "capability"
      },
      "Invocation Contract": {
        "docId": "tool",
        "slug": "invocation-contract"
      },
      "Inputs": {
        "docId": "tool",
        "slug": "inputs"
      },
      "Outputs": {
        "docId": "tool",
        "slug": "outputs"
      },
      "State": {
        "docId": "tool",
        "slug": "state"
      },
      "InvokeTool": {
        "docId": "tool",
        "slug": "invoketool"
      },
      "DescribeCapability": {
        "docId": "tool",
        "slug": "describecapability"
      },
      "Checklist": {
        "docId": "checklist"
      }
    }
  },
  "workspace#evaluateconcept": {
    "operation": {
      "ref": "workspace#evaluateconcept",
      "title": "EvaluateConcept",
      "content": "When an LLM encounters a [Concept], it should:\n1.  **Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`).\n    *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*\n2.  **Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].\n3.  **Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.\n4.  **Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced.",
      "attrs": {},
      "steps": [
        "**Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`). *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*",
        "**Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].",
        "**Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.",
        "**Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Concept": {
        "docId": "concept"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Playbook": {
        "docId": "playbook"
      },
      "Role": {
        "docId": "role"
      }
    }
  },
  "document_optimizer#executeplaybook": {
    "operation": {
      "ref": "document_optimizer#executeplaybook",
      "title": "ExecutePlaybook",
      "content": "When instructed to run a [Playbook], do the following:\n1. **Evaluate Document:** Run [EvaluateDocument](./document.busy.md#evaluatedocument) to load setup, state, and private operations.\n2. **Identify Steps:** Parse the `# [Operations](./document.busy.md#operations-section)` section for non-private [Sequence Step] definitions (e.g., headings describing `Step 1`, `Step A`, etc.) or follow an explicit steps table if provided. Maintain the declared order.\n3. **Resolve Each Step:** For each step in order:\n   - Evaluate its [Condition] (if any). If the condition is false, skip the step and log the decision.\n   - If the step references a [Private Operation], execute it directly.\n   - Otherwise, locate the referenced callable (another [Operation], [Prompt], [Document], or [Tool]) and gather required inputs.\n   - If a [Role Context] is defined, invoke `ExecuteRole` for that role, run the callable, then restore the previous role/state.\n   - Capture outputs or state updates as directed by the step definition.\n4. **Handle Failures:** If any step cannot be resolved or produces an error, stop execution and return an [error](./operation.busy.md#error) that includes the step name and details.\n5. **Run Checklist:** After the main sequence completes, execute [RunChecklist] if the [Playbook] defines one so every verification item is confirmed.\n6. **Summarize Results:** After all steps succeed, provide a concise summary of actions performed and outputs produced.",
      "attrs": {},
      "steps": [
        "**Evaluate Document:** Run [EvaluateDocument](./document.busy.md#evaluatedocument) to load setup, state, and private operations.",
        "**Identify Steps:** Parse the `# [Operations](./document.busy.md#operations-section)` section for non-private [Sequence Step] definitions (e.g., headings describing `Step 1`, `Step A`, etc.) or follow an explicit steps table if provided. Maintain the declared order.",
        "**Resolve Each Step:** For each step in order:",
        "Evaluate its [Condition] (if any). If the condition is false, skip the step and log the decision.",
        "If the step references a [Private Operation], execute it directly.",
        "Otherwise, locate the referenced callable (another [Operation], [Prompt], [Document], or [Tool]) and gather required inputs.",
        "If a [Role Context] is defined, invoke `ExecuteRole` for that role, run the callable, then restore the previous role/state.",
        "Capture outputs or state updates as directed by the step definition.",
        "**Handle Failures:** If any step cannot be resolved or produces an error, stop execution and return an [error](./operation.busy.md#error) that includes the step name and details.",
        "**Run Checklist:** After the main sequence completes, execute [RunChecklist] if the [Playbook] defines one so every verification item is confirmed.",
        "**Summarize Results:** After all steps succeed, provide a concise summary of actions performed and outputs produced."
      ],
      "checklist": [
        "Document evaluated; private operations loaded.",
        "All steps resolved or skipped based on conditions with reasons logged.",
        "Failures reported with step names and details; execution halted appropriately.",
        "Checklist (if defined) executed after main sequence.",
        "Final summary produced and logged."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  },
  "document_optimizer#listplaybooksteps": {
    "operation": {
      "ref": "document_optimizer#listplaybooksteps",
      "title": "ListPlaybookSteps",
      "content": "Enumerate the discrete [Sequence Step]s in this [Playbook].\n1. Parse the [Playbook] after [EvaluateDocument].\n2. Collect step headings (excluding [Private Operation]s) in execution order.\n3. Present the list as a numbered outline including the target callable and any role context.",
      "attrs": {},
      "steps": [
        "Parse the [Playbook] after [EvaluateDocument].",
        "Collect step headings (excluding [Private Operation]s) in execution order.",
        "Present the list as a numbered outline including the target callable and any role context."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  },
  "document_optimizer#evaluatedocument": {
    "operation": {
      "ref": "document_optimizer#evaluatedocument",
      "title": "EvaluateDocument",
      "content": "When an LLM processes a [Document], it should:\n1.  **Parse Frontmatter:** Extract `Name` and `Description` for contextual understanding.\n2.  **Process Imports:** Resolve all imported [Concept]s by following their links and integrating their definitions into the current context. If any import cannot be resolved (invalid path or anchor), immediately return an [error] describing the missing import and stop further processing; do not execute [Setup](./document.busy.md#setup-section) or later steps.\n3.  **Execute Setup:** Follow the instructions in the `# [Setup](./document.busy.md#setup-section)` section, establishing any required context, persona, or initial state. Persist any specified state to memory files.\n4.  **Enforce Strict Execution:** All defined [Operation]s MUST be executed precisely as their steps dictate, including any [Checklist] sections they define.\n5.  **Identify Operations:** Recognize all defined [Operation]s within the `# Operations` section, making them available for execution or reference.\n6.  **Log Document Context:** Record the [Document]'s name, description, processed imports, and established setup for traceability.",
      "attrs": {},
      "steps": [
        "**Parse Frontmatter:** Extract `Name` and `Description` for contextual understanding.",
        "**Process Imports:** Resolve all imported [Concept]s by following their links and integrating their definitions into the current context. If any import cannot be resolved (invalid path or anchor), immediately return an [error] describing the missing import and stop further processing; do not execute [Setup](./document.busy.md#setup-section) or later steps.",
        "**Execute Setup:** Follow the instructions in the `# [Setup](./document.busy.md#setup-section)` section, establishing any required context, persona, or initial state. Persist any specified state to memory files.",
        "**Enforce Strict Execution:** All defined [Operation]s MUST be executed precisely as their steps dictate, including any [Checklist] sections they define.",
        "**Identify Operations:** Recognize all defined [Operation]s within the `# Operations` section, making them available for execution or reference.",
        "**Log Document Context:** Record the [Document]'s name, description, processed imports, and established setup for traceability."
      ],
      "checklist": [
        "Frontmatter parsed and `Name`/`Description` captured.",
        "Imports resolved and integrated into context; unresolved imports produce a clear [error] and halt execution prior to Setup.",
        "Setup executed; any state persisted as specified.",
        "All Operations identified and made available.",
        "Document context logged (including resolved imports and setup notes)."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  },
  "document_optimizer#listoperations": {
    "operation": {
      "ref": "document_optimizer#listoperations",
      "title": "ListOperations",
      "content": "Parses the [Document] to find all defined [Operation]s under the `# Operations` section.",
      "attrs": {},
      "steps": [
        "Parse the document.",
        "Identify all `## Headings` under `# Operations`.",
        "Present the results to the user."
      ],
      "checklist": [
        "The output MUST be presented as a numbered list.",
        "Each number MUST correspond to an operation.",
        "The user MUST be able to invoke an operation by its number.",
        "Returns only operations defined under `# Operations`.",
        "Output formatted as a numbered list.",
        "Each item clearly maps to an invocable operation."
      ]
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  },
  "document_optimizer#evaluateconcept": {
    "operation": {
      "ref": "document_optimizer#evaluateconcept",
      "title": "EvaluateConcept",
      "content": "When an LLM encounters a [Concept], it should:\n1.  **Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`).\n    *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*\n2.  **Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].\n3.  **Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.\n4.  **Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced.",
      "attrs": {},
      "steps": [
        "**Identify the Concept:** Recognize the named [Concept] (e.g., `[MyConcept][Concept]`). *Note: All references to other [Concept]s, [Document]s, or [Operation]s should use the preferred markdown reference style: define the link at the top (e.g., `[ReferenceName]:(./path/to/file.busy.md#optional-anchor)`) and then refer to it as `[ReferenceName]` or `[LocalAlias][ReferenceName]`. Inline links are acceptable but less preferred.*",
        "**Locate Definition:** If this is the first time you've seen the [Concept], follow the provided link to its explicit definition. The definition file or anchor may not actually exist. This is fine, as the link to that resource could simply be a namespace or placeholder for the [Concept].",
        "**Integrate Context:** Interpret and incorporate the definition and any associated context into its working memory for the current task.",
        "**Apply Meaning:** Use the integrated definition to interpret and apply the [Concept]'s meaning consistently throughout the execution of the [Document] or [Operation] where it is referenced."
      ],
      "checklist": []
    },
    "defs": [],
    "calls": [],
    "symbols": {
      "Playbook": {
        "docId": "playbook"
      },
      "Document": {
        "docId": "document"
      },
      "Operation": {
        "docId": "operation"
      },
      "Checklist": {
        "docId": "checklist"
      },
      "WorkspaceContext": {},
      "Trace": {},
      "Trace Directory": {
        "slug": "trace-directory"
      },
      "Run Directory": {
        "slug": "run-directory"
      },
      "ChecklistVerification": {
        "slug": "checklistverification"
      },
      "RecordChecklistVerification": {
        "slug": "recordchecklistverification"
      }
    }
  }
}